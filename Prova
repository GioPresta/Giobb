Hai ragione, grazie per avermelo fatto notare.

La tua logica corretta Ã¨:


---

âœ… Corretto comportamento desiderato

1. Una nuova riga nel CSV inizia solo quando una riga del .txt comincia con esattamente 3 spazi ('   ').


2. Tutte le righe successive (senza 3 spazi iniziali) fanno parte della stessa riga CSV.


3. La separazione in colonne avviene su tutte le righe, ma con logica diversa:

Le colonne si dividono se:

Ci sono piÃ¹ di 3 spazi consecutivi

Oppure tra due numeri c'Ã¨ anche solo 1 spazio


Tuttavia:

Se compare la parola "Errore" in qualunque riga, tutto il testo che segue (anche su righe successive) va in unâ€™unica colonna fino a incontrare una nuova riga con 3 spazi.





In altre parole:

> La modalitÃ  "errore accorpato" puÃ² iniziare in qualsiasi riga, non solo nella riga iniziale, e prosegue fino alla prossima riga con 3 spazi.




---

ðŸ§© Codice aggiornato per rispettare questa logica

import re

def formatta_errore_csv(path_txt, output_csv):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    righe_formattate = []
    riga_corrente = []
    in_sezione_errore = False
    errore_buffer = ''

    def splitta_colonne_intelligente(riga):
        tokens = riga.strip().split()
        colonne = []
        buffer = ''

        for i, token in enumerate(tokens):
            if token.isdigit() and (i == 0 or tokens[i - 1].isdigit()):
                if buffer:
                    colonne.append(buffer.strip())
                    buffer = ''
                colonne.append(token)
            else:
                if buffer:
                    buffer += ' ' + token
                else:
                    buffer = token

        if buffer:
            colonne.append(buffer.strip())

        # Ora split su 4+ spazi tra gruppi giÃ  puliti
        joined = ' '.join(colonne)
        return [c.strip() for c in re.split(r'\s{4,}', joined) if c.strip()]

    for riga in righe:
        testo = riga.rstrip('\n')

        if testo.startswith('   ') and not testo.startswith('    '):  # Nuova riga
            if riga_corrente:
                if errore_buffer.strip():
                    riga_corrente.append(errore_buffer.strip())
                    errore_buffer = ''
                    in_sezione_errore = False
                righe_formattate.append(';'.join(riga_corrente))
                riga_corrente = []

            colonne = splitta_colonne_intelligente(testo)

            # Cerca la parola "Errore" in qualunque colonna
            for idx, col in enumerate(colonne):
                if 'Errore' in col:
                    in_sezione_errore = True
                    errore_buffer = col
                    riga_corrente = colonne[:idx]
                    break
            else:
                riga_corrente = colonne

        else:
            # Riga di continuazione
            if in_sezione_errore:
                errore_buffer += ' ' + testo.strip()
            else:
                # Split e aggiungi normalmente
                colonne = splitta_colonne_intelligente(testo)
                riga_corrente.extend(colonne)

    # Ultima riga da chiudere
    if riga_corrente:
        if errore_buffer.strip():
            riga_corrente.append(errore_buffer.strip())
        righe_formattate.append(';'.join(riga_corrente))

    with open(output_csv, 'w', encoding='utf-8') as f:
        for r in righe_formattate:
            f.write(r + '\n')

    print(f"âœ… File CSV generato correttamente: {output_csv}")


---

ðŸ§ª Esempio pratico

Input .txt:

3    00012345    Info Iniziale   Errore Bloccante
     Stack trace inizia qui
     altri dettagli su errore
   4    00012346    Messaggio OK     Tutto a posto

Output .csv:

3;00012345;Info Iniziale;Errore Bloccante Stack trace inizia qui altri dettagli su errore
4;00012346;Messaggio OK;Tutto a posto


---

Vuoi che tutto lâ€™errore vada **nella stessa col

