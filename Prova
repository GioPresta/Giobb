Perfetto! Allora specifichiamo:


---

‚úÖ Regole aggiornate

Elimina le prime 3 righe

Una riga inizia una nuova riga CSV solo se inizia con esattamente 3 spazi ‚Üí text.startswith('   ') and not text.startswith('    ')

Le colonne sono delimitate da almeno 3 spazi consecutivi ‚Üí re.split(r'\s{3,}', ...)

Le righe che non iniziano con esattamente 3 spazi sono da concatenare alla riga corrente, come colonne successive

Il CSV usa il punto e virgola ; come separatore



---

üß© Blocco Python aggiornato (da aggiungere al tuo script)

import re

def formatta_blocchi_da_testo(path_txt, output_csv):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    # Elimina le prime 3 righe
    righe = righe[3:]

    righe_formattate = []
    riga_corrente = []

    for riga in righe:
        testo = riga.rstrip('\n')

        # Se inizia con ESATTAMENTE 3 spazi
        if testo.startswith('   ') and not testo.startswith('    '):
            if riga_corrente:
                righe_formattate.append(';'.join(riga_corrente))
            riga_corrente = [col.strip() for col in re.split(r'\s{3,}', testo.strip()) if col.strip()]
        else:
            nuove_colonne = [col.strip() for col in re.split(r'\s{3,}', testo.strip()) if col.strip()]
            riga_corrente.extend(nuove_colonne)

    if riga_corrente:
        righe_formattate.append(';'.join(riga_corrente))

    with open(output_csv, 'w', encoding='utf-8') as f:
        for riga in righe_formattate:
            f.write(riga + '\n')

    print(f"‚úÖ CSV formattato generato correttamente: {output_csv}")


---

‚úîÔ∏è Come integrarlo

Nel tuo main(), dopo pulisci_output(...), aggiungi:

formatta_blocchi_da_testo(percorso_txt, percorso_csv)


---

Se vuoi anche aggiungere intestazioni, o gestire campi vuoti con placeholder (es. "" o NULL), fammi sapere!

