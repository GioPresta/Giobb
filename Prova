import xml.etree.ElementTree as ET
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
import json
import re
from datetime import datetime

def xml_to_dict(element):
    """Converte un elemento XML in dizionario"""
    result = {}
    
    # Aggiungi attributi
    if element.attrib:
        result.update(element.attrib)
    
    # Gestisci elementi figli
    children = list(element)
    if children:
        child_dict = {}
        for child in children:
            child_data = xml_to_dict(child)
            if child.tag in child_dict:
                # Se esiste gi√†, crea una lista
                if not isinstance(child_dict[child.tag], list):
                    child_dict[child.tag] = [child_dict[child.tag]]
                child_dict[child.tag].append(child_data)
            else:
                child_dict[child.tag] = child_data
        result.update(child_dict)
    
    # Aggiungi testo se presente
    if element.text and element.text.strip():
        if result:
            result['_text'] = element.text.strip()
        else:
            return element.text.strip()
    
    return result

def flatten_dict(d, parent_key='', sep='_'):
    """Appiattisce un dizionario annidato"""
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        elif isinstance(v, list):
            for i, item in enumerate(v):
                if isinstance(item, dict):
                    items.extend(flatten_dict(item, f"{new_key}_{i}", sep=sep).items())
                else:
                    items.append((f"{new_key}_{i}", item))
        else:
            items.append((new_key, v))
    return dict(items)

def apply_formatting(worksheet):
    """Applica formattazione al foglio Excel"""
    # Stile header
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_alignment = Alignment(horizontal="center", vertical="center")
    
    # Bordi
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Applica stile agli header (prima riga)
    for cell in worksheet[1]:
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = header_alignment
        cell.border = thin_border
    
    # Applica bordi a tutte le celle con dati
    for row in worksheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.border = thin_border
                if cell.row > 1:  # Non header
                    cell.alignment = Alignment(vertical="center")
    
    # Auto-dimensiona le colonne
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            if cell.value:
                max_length = max(max_length, len(str(cell.value)))
        
        adjusted_width = min(max_length + 2, 50)  # Max 50 caratteri
        worksheet.column_dimensions[column_letter].width = adjusted_width

def xml_to_xlsx(xml_file_path, xlsx_file_path, flatten=True):
    """
    Converte XML in XLSX con formattazione
    
    Args:
        xml_file_path (str): Percorso del file XML
        xlsx_file_path (str): Percorso del file XLSX di output
        flatten (bool): Se appiattire la struttura XML annidata
    """
    try:
        # Leggi e parsa XML
        tree = ET.parse(xml_file_path)
        root = tree.getroot()
        
        # Converte XML in dizionario
        data_dict = xml_to_dict(root)
        
        # Gestisci diversi tipi di struttura XML
        if isinstance(data_dict, dict):
            # Cerca il primo livello che contiene liste (record multipli)
            records = []
            
            def find_records(obj, path=""):
                nonlocal records
                if isinstance(obj, list):
                    records.extend(obj)
                elif isinstance(obj, dict):
                    for key, value in obj.items():
                        find_records(value, f"{path}.{key}" if path else key)
            
            find_records(data_dict)
            
            # Se non troviamo record multipli, usa l'oggetto root
            if not records:
                records = [data_dict]
        else:
            records = [data_dict]
        
        # Appiattisci i dizionari se richiesto
        if flatten:
            flattened_records = []
            for record in records:
                if isinstance(record, dict):
                    flattened_records.append(flatten_dict(record))
                else:
                    flattened_records.append({'value': record})
            records = flattened_records
        
        # Converti in DataFrame
        df = pd.DataFrame(records)
        
        # Se il DataFrame √® vuoto, crea uno con i dati raw
        if df.empty:
            df = pd.DataFrame([{'root': str(data_dict)}])
        
        # Crea workbook Excel
        wb = Workbook()
        ws = wb.active
        ws.title = "XML_Data"
        
        # Aggiungi dati al foglio
        for r in dataframe_to_rows(df, index=False, header=True):
            ws.append(r)
        
        # Applica formattazione
        apply_formatting(ws)
        
        # Salva file
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione completata!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        print(f"üìä Righe elaborate: {len(df)}")
        print(f"üìã Colonne: {len(df.columns)}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione: {str(e)}")
        return False

def xml_to_xlsx_multiple_sheets(xml_file_path, xlsx_file_path):
    """
    Versione avanzata che crea fogli separati per diversi tipi di elementi
    """
    try:
        tree = ET.parse(xml_file_path)
        root = tree.getroot()
        
        wb = Workbook()
        # Rimuovi il foglio default
        wb.remove(wb.active)
        
        # Raggruppa elementi per tag
        elements_by_tag = {}
        
        def collect_elements(element, parent_tag=""):
            tag = element.tag
            full_tag = f"{parent_tag}_{tag}" if parent_tag else tag
            
            if full_tag not in elements_by_tag:
                elements_by_tag[full_tag] = []
            
            element_dict = xml_to_dict(element)
            elements_by_tag[full_tag].append(element_dict)
            
            # Esplora elementi figli
            for child in element:
                collect_elements(child, full_tag)
        
        # Raccogli tutti gli elementi
        for child in root:
            collect_elements(child)
        
        # Se non ci sono elementi figli, usa il root
        if not elements_by_tag:
            elements_by_tag[root.tag] = [xml_to_dict(root)]
        
        # Crea un foglio per ogni tipo di elemento
        for tag, elements in elements_by_tag.items():
            if elements:
                # Pulisci nome foglio (Excel ha limitazioni)
                sheet_name = tag.replace("/", "_").replace("\\", "_")[:31]
                
                # Appiattisci elementi
                flattened = [flatten_dict(elem) if isinstance(elem, dict) else {'value': elem} 
                           for elem in elements]
                
                df = pd.DataFrame(flattened)
                
                if not df.empty:
                    ws = wb.create_sheet(title=sheet_name)
                    
                    # Aggiungi dati
                    for r in dataframe_to_rows(df, index=False, header=True):
                        ws.append(r)
                    
                    # Applica formattazione
                    apply_formatting(ws)
        
        # Se non ci sono fogli, crea uno vuoto
        if not wb.worksheets:
            ws = wb.create_sheet(title="Empty")
            ws.append(["Nessun dato trovato nel file XML"])
        
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione completata con {len(wb.worksheets)} fogli!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione: {str(e)}")
        return False

def parse_sql_insert_file(file_path):
    """
    Parsa un file SQL con INSERT statements e converte in DataFrame
    Versione migliorata per gestire valori complessi
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        
        # Pattern migliorato per estrarre gli INSERT statements
        insert_pattern = r'Insert\s+into\s+EXPORT_TABLE\s*\((.*?)\)\s+values\s*\((.*?)\)\s*;'
        
        # Trova tutti gli INSERT statements
        matches = re.findall(insert_pattern, content, re.IGNORECASE | re.DOTALL)
        
        if not matches:
            print("‚ùå Nessun INSERT statement trovato")
            print("üîç Provo pattern alternativi...")
            
            # Pattern alternativo pi√π flessibile
            alt_pattern = r'Insert.*?EXPORT_TABLE.*?\((.*?)\).*?values.*?\((.*?)\)'
            matches = re.findall(alt_pattern, content, re.IGNORECASE | re.DOTALL)
            
            if not matches:
                print("‚ùå Nessun pattern riconosciuto")
                return None
        
        print(f"üìä Trovati {len(matches)} INSERT statements")
        
        # Estrai i nomi delle colonne dal primo INSERT
        columns_raw = matches[0][0].strip()
        columns = [col.strip() for col in re.split(r',(?![^()]*\))', columns_raw)]
        
        print(f"üìã Colonne trovate ({len(columns)}): {columns}")
        
        # Funzione migliorata per parsare i valori
        def parse_values(values_string):
            values = []
            current = ""
            in_quotes = False
            quote_char = None
            parentheses_count = 0
            i = 0
            
            while i < len(values_string):
                char = values_string[i]
                
                if not in_quotes:
                    if char in ["'", '"']:
                        in_quotes = True
                        quote_char = char
                        current += char
                    elif char == '(':
                        parentheses_count += 1
                        current += char
                    elif char == ')':
                        parentheses_count -= 1
                        current += char
                    elif char == ',' and parentheses_count == 0:
                        # Virgola a livello principale - separa i valori
                        values.append(current.strip())
                        current = ""
                    else:
                        current += char
                else:
                    # Siamo dentro le virgolette
                    if char == quote_char:
                        # Controlla se √® un escape (doppio apice)
                        if i + 1 < len(values_string) and values_string[i + 1] == quote_char:
                            current += char + char
                            i += 1  # Salta il prossimo carattere
                        else:
                            in_quotes = False
                            current += char
                            quote_char = None
                    else:
                        current += char
                
                i += 1
            
            # Aggiungi l'ultimo valore
            if current.strip():
                values.append(current.strip())
            
            return values
        
        # Elabora tutti i valori
        all_rows = []
        skipped_rows = 0
        
        for i, match in enumerate(matches):
            try:
                values_raw = match[1].strip()
                values = parse_values(values_raw)
                
                # Pulisci i valori
                cleaned_values = []
                for val in values:
                    val = val.strip()
                    # Rimuovi virgolette esterne se presenti
                    if len(val) >= 2:
                        if (val.startswith("'") and val.endswith("'")) or \
                           (val.startswith('"') and val.endswith('"')):
                            val = val[1:-1]
                            # De-escape virgolette doppie
                            if "''" in val:
                                val = val.replace("''", "'")
                            if '""' in val:
                                val = val.replace('""', '"')
                    
                    cleaned_values.append(val)
                
                # Debug per la prima riga
                if i == 0:
                    print(f"üîç Prima riga - Valori trovati ({len(cleaned_values)}):")
                    for j, val in enumerate(cleaned_values):
                        print(f"  {j+1}. {val[:100]}...")
                
                # Verifica corrispondenza colonne
                if len(cleaned_values) == len(columns):
                    all_rows.append(cleaned_values)
                else:
                    skipped_rows += 1
                    if skipped_rows <= 3:  # Mostra solo i primi errori
                        print(f"‚ö†Ô∏è  Riga {i+1}: {len(cleaned_values)} valori vs {len(columns)} colonne")
                        if len(cleaned_values) < 10:  # Mostra valori solo se non troppi
                            print(f"    Valori: {cleaned_values}")
                
            except Exception as e:
                skipped_rows += 1
                print(f"‚ùå Errore riga {i+1}: {str(e)}")
        
        if skipped_rows > 3:
            print(f"‚ö†Ô∏è  ... e altre {skipped_rows - 3} righe ignorate")
        
        if not all_rows:
            print("‚ùå Nessuna riga valida trovata")
            return None
        
        # Crea DataFrame
        df = pd.DataFrame(all_rows, columns=columns)
        
        print(f"‚úÖ Elaborazione completata: {len(df)} righe elaborate su {len(matches)} totali")
        return df
        
    except Exception as e:
        print(f"‚ùå Errore nel parsing SQL: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def sql_to_xlsx(sql_file_path, xlsx_file_path):
    """
    Converte un file SQL con INSERT statements in XLSX formattato
    """
    try:
        # Parsa il file SQL
        df = parse_sql_insert_file(sql_file_path)
        
        if df is None or df.empty:
            print("‚ùå Nessun dato da convertire")
            return False
        
        # Crea workbook Excel
        wb = Workbook()
        ws = wb.active
        ws.title = "EXPORT_TABLE"
        
        # Aggiungi dati al foglio
        for r in dataframe_to_rows(df, index=False, header=True):
            ws.append(r)
        
        # Applica formattazione
        apply_formatting(ws)
        
        # Formattazione speciale per colonne specifiche
        for col_num, col_name in enumerate(df.columns, 1):
            col_letter = ws.cell(row=1, column=col_num).column_letter
            
            # Formattazione per colonne numeriche (VALORE_QUOTE, etc.)
            if 'valore' in col_name.lower() or 'quote' in col_name.lower():
                for row in range(2, len(df) + 2):
                    cell = ws.cell(row=row, column=col_num)
                    if cell.value and str(cell.value).replace('.', '').replace(',', '').isdigit():
                        try:
                            cell.value = float(str(cell.value).replace(',', '.'))
                            cell.number_format = '#,##0.00'
                        except:
                            pass
            
            # Formattazione per date
            elif 'data' in col_name.lower():
                for row in range(2, len(df) + 2):
                    cell = ws.cell(row=row, column=col_num)
                    if cell.value:
                        cell.number_format = 'DD/MM/YYYY'
        
        # Salva file
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione SQL completata!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        print(f"üìä Righe elaborate: {len(df)}")
        print(f"üìã Colonne: {len(df.columns)}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione SQL: {str(e)}")
        return False

def auto_detect_and_convert(input_file, output_file):
    """
    Rileva automaticamente il tipo di file e applica la conversione appropriata
    """
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            first_lines = f.read(1000).lower()
        
        if 'insert into' in first_lines and 'values' in first_lines:
            print("üìÑ Rilevato file SQL con INSERT statements")
            return sql_to_xlsx(input_file, output_file)
        elif '<?xml' in first_lines or '<' in first_lines:
            print("üìÑ Rilevato file XML")
            return xml_to_xlsx(input_file, output_file)
        else:
            print("‚ùå Formato file non riconosciuto")
            return False
            
    except Exception as e:
        print(f"‚ùå Errore nel rilevamento tipo file: {str(e)}")
        return False

# Esempio di utilizzo
if __name__ == "__main__":
    # Auto-rilevamento e conversione
    auto_detect_and_convert("export.xml", "output.xlsx")
    
    # Conversione SQL specifica
    # sql_to_xlsx("export.sql", "output_sql.xlsx")
    
    # Conversione XML classica
    # xml_to_xlsx("input.xml", "output_xml.xlsx")