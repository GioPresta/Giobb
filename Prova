Eccoti lo script completo, corretto e definitivo, con:


---

‚úÖ Caratteristiche finali:

Legge tutti i file .txt nella cartella

Estrae solo il blocco da LIVELLO fino alla riga di asterischi (*****)

Rimuove righe decorative (----, ====, ecc.)

Scrive:

un file riepilogo.txt

un file riepilogo.csv leggibile da Excel


‚úÖ Scrive una sola volta l‚Äôintestazione (es. Gravit√†  Oggetto  Errore)

Anche se l‚Äôintestazione si ripete nei contenuti degli altri file




---

üßæ Codice completo (non richiede librerie esterne)

import os
import re
import csv

# Regex per struttura file batch
END_SECTION_PATTERN = re.compile(r'^\s*\*{5,}\s*$')                # *****...
DECORATION_PATTERN = re.compile(r'^[\s\-\*=_\.]{4,}$')             # ----, ====
START_HEADER_PATTERN = re.compile(r'^\s*LIVELLO\b', re.IGNORECASE) # Inizio sezione

def extract_section(file_path):
    """Estrae intestazione + righe dati da un file .txt"""
    with open(file_path, 'r', encoding='latin1') as f:
        in_section = False
        header = None
        content = []

        for line in f:
            line_clean = line.strip()

            if not in_section:
                if START_HEADER_PATTERN.match(line_clean):
                    header = line_clean
                    in_section = True
            else:
                if END_SECTION_PATTERN.match(line_clean):
                    break
                elif not DECORATION_PATTERN.match(line_clean) and line_clean:
                    content.append(line.rstrip())

        return header, content


def write_csv_file(header_line, data_lines, output_csv='riepilogo.csv'):
    """Scrive i dati estratti in un file CSV compatibile con Excel"""
    with open(output_csv, 'w', encoding='utf-8', newline='') as f:
        writer = csv.writer(f, delimiter=';')

        headers = re.split(r'\s{2,}', header_line.strip())
        writer.writerow(headers)

        for line in data_lines:
            values = re.split(r'\s{2,}', line.strip())
            writer.writerow(values)

    print(f"üìÑ CSV generato: {output_csv}")


def merge_all_reports(output_txt='riepilogo.txt', output_csv='riepilogo.csv'):
    current_dir = os.getcwd()
    txt_files = [f for f in os.listdir(current_dir)
                 if f.endswith('.txt') and f != output_txt]

    merged_content = []
    saved_header = None

    for txt_file in txt_files:
        file_path = os.path.join(current_dir, txt_file)
        header, content = extract_section(file_path)

        if saved_header is None and header:
            saved_header = header.strip()

        # Elimina intestazioni duplicate nei contenuti successivi
        filtered_content = [
            line for line in content
            if saved_header is None or line.strip() != saved_header
        ]

        merged_content.extend(filtered_content)

    # Scrittura file di testo
    with open(output_txt, 'w', encoding='utf-8') as out:
        if saved_header:
            out.write(saved_header + '\n')
        out.write('\n'.join(merged_content))
        out.write('\n')
    print(f"üìù File di testo generato: {output_txt}")

    # Scrittura file CSV
    if saved_header:
        write_csv_file(saved_header, merged_content, output_csv)


if __name__ == "__main__":
    merge_all_reports()


---

üìÇ Come usarlo

1. Salva il file come merge_batch_reports.py


2. Mettilo nella stessa cartella dei .txt


3. Apri il terminale in quella cartella


4. Esegui:



python merge_batch_reports.py


---

üü¢ Risultato:

‚úÖ riepilogo.txt: testo pulito, una

