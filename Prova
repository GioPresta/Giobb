import xml.etree.ElementTree as ET
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
import json
import re
from datetime import datetime

def xml_to_dict(element):
    """Converte un elemento XML in dizionario"""
    result = {}
    
    # Aggiungi attributi
    if element.attrib:
        result.update(element.attrib)
    
    # Gestisci elementi figli
    children = list(element)
    if children:
        child_dict = {}
        for child in children:
            child_data = xml_to_dict(child)
            if child.tag in child_dict:
                # Se esiste gi√†, crea una lista
                if not isinstance(child_dict[child.tag], list):
                    child_dict[child.tag] = [child_dict[child.tag]]
                child_dict[child.tag].append(child_data)
            else:
                child_dict[child.tag] = child_data
        result.update(child_dict)
    
    # Aggiungi testo se presente
    if element.text and element.text.strip():
        if result:
            result['_text'] = element.text.strip()
        else:
            return element.text.strip()
    
    return result

def flatten_dict(d, parent_key='', sep='_'):
    """Appiattisce un dizionario annidato"""
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        elif isinstance(v, list):
            for i, item in enumerate(v):
                if isinstance(item, dict):
                    items.extend(flatten_dict(item, f"{new_key}_{i}", sep=sep).items())
                else:
                    items.append((f"{new_key}_{i}", item))
        else:
            items.append((new_key, v))
    return dict(items)

def apply_formatting(worksheet):
    """Applica formattazione al foglio Excel"""
    # Stile header
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_alignment = Alignment(horizontal="center", vertical="center")
    
    # Bordi
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Applica stile agli header (prima riga)
    for cell in worksheet[1]:
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = header_alignment
        cell.border = thin_border
    
    # Applica bordi a tutte le celle con dati
    for row in worksheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.border = thin_border
                if cell.row > 1:  # Non header
                    cell.alignment = Alignment(vertical="center")
    
    # Auto-dimensiona le colonne
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            if cell.value:
                max_length = max(max_length, len(str(cell.value)))
        
        adjusted_width = min(max_length + 2, 50)  # Max 50 caratteri
        worksheet.column_dimensions[column_letter].width = adjusted_width

def xml_to_xlsx(xml_file_path, xlsx_file_path, flatten=True):
    """
    Converte XML in XLSX con formattazione
    
    Args:
        xml_file_path (str): Percorso del file XML
        xlsx_file_path (str): Percorso del file XLSX di output
        flatten (bool): Se appiattire la struttura XML annidata
    """
    try:
        # Leggi e parsa XML
        tree = ET.parse(xml_file_path)
        root = tree.getroot()
        
        # Converte XML in dizionario
        data_dict = xml_to_dict(root)
        
        # Gestisci diversi tipi di struttura XML
        if isinstance(data_dict, dict):
            # Cerca il primo livello che contiene liste (record multipli)
            records = []
            
            def find_records(obj, path=""):
                nonlocal records
                if isinstance(obj, list):
                    records.extend(obj)
                elif isinstance(obj, dict):
                    for key, value in obj.items():
                        find_records(value, f"{path}.{key}" if path else key)
            
            find_records(data_dict)
            
            # Se non troviamo record multipli, usa l'oggetto root
            if not records:
                records = [data_dict]
        else:
            records = [data_dict]
        
        # Appiattisci i dizionari se richiesto
        if flatten:
            flattened_records = []
            for record in records:
                if isinstance(record, dict):
                    flattened_records.append(flatten_dict(record))
                else:
                    flattened_records.append({'value': record})
            records = flattened_records
        
        # Converti in DataFrame
        df = pd.DataFrame(records)
        
        # Se il DataFrame √® vuoto, crea uno con i dati raw
        if df.empty:
            df = pd.DataFrame([{'root': str(data_dict)}])
        
        # Crea workbook Excel
        wb = Workbook()
        ws = wb.active
        ws.title = "XML_Data"
        
        # Aggiungi dati al foglio
        for r in dataframe_to_rows(df, index=False, header=True):
            ws.append(r)
        
        # Applica formattazione
        apply_formatting(ws)
        
        # Salva file
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione completata!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        print(f"üìä Righe elaborate: {len(df)}")
        print(f"üìã Colonne: {len(df.columns)}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione: {str(e)}")
        return False

def xml_to_xlsx_multiple_sheets(xml_file_path, xlsx_file_path):
    """
    Versione avanzata che crea fogli separati per diversi tipi di elementi
    """
    try:
        tree = ET.parse(xml_file_path)
        root = tree.getroot()
        
        wb = Workbook()
        # Rimuovi il foglio default
        wb.remove(wb.active)
        
        # Raggruppa elementi per tag
        elements_by_tag = {}
        
        def collect_elements(element, parent_tag=""):
            tag = element.tag
            full_tag = f"{parent_tag}_{tag}" if parent_tag else tag
            
            if full_tag not in elements_by_tag:
                elements_by_tag[full_tag] = []
            
            element_dict = xml_to_dict(element)
            elements_by_tag[full_tag].append(element_dict)
            
            # Esplora elementi figli
            for child in element:
                collect_elements(child, full_tag)
        
        # Raccogli tutti gli elementi
        for child in root:
            collect_elements(child)
        
        # Se non ci sono elementi figli, usa il root
        if not elements_by_tag:
            elements_by_tag[root.tag] = [xml_to_dict(root)]
        
        # Crea un foglio per ogni tipo di elemento
        for tag, elements in elements_by_tag.items():
            if elements:
                # Pulisci nome foglio (Excel ha limitazioni)
                sheet_name = tag.replace("/", "_").replace("\\", "_")[:31]
                
                # Appiattisci elementi
                flattened = [flatten_dict(elem) if isinstance(elem, dict) else {'value': elem} 
                           for elem in elements]
                
                df = pd.DataFrame(flattened)
                
                if not df.empty:
                    ws = wb.create_sheet(title=sheet_name)
                    
                    # Aggiungi dati
                    for r in dataframe_to_rows(df, index=False, header=True):
                        ws.append(r)
                    
                    # Applica formattazione
                    apply_formatting(ws)
        
        # Se non ci sono fogli, crea uno vuoto
        if not wb.worksheets:
            ws = wb.create_sheet(title="Empty")
            ws.append(["Nessun dato trovato nel file XML"])
        
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione completata con {len(wb.worksheets)} fogli!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione: {str(e)}")
        return False

def parse_sql_insert_file(file_path):
    """
    Parsa un file SQL con INSERT statements - versione specifica per la struttura mostrata
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        
        print("üîç Analizzando il contenuto del file...")
        
        # Trova tutte le righe INSERT
        lines = content.split('\n')
        insert_lines = []
        
        for line in lines:
            line = line.strip()
            if line.lower().startswith('insert into export_table'):
                insert_lines.append(line)
        
        if not insert_lines:
            print("‚ùå Nessun INSERT statement trovato")
            return None
        
        print(f"üìä Trovate {len(insert_lines)} righe INSERT")
        
        # Analizza la prima riga per capire la struttura
        first_line = insert_lines[0]
        print(f"üîç Prima riga: {first_line[:200]}...")
        
        # Pattern pi√π specifico per la tua struttura
        # La struttura sembra essere: Insert into EXPORT_TABLE (col1,col2,col3,col4,col5,col6) values (val1,val2,val3,val4,val5,val6);
        pattern = r'Insert\s+into\s+EXPORT_TABLE\s*\((.*?)\)\s+values\s*\((.*?)\)\s*;?'
        
        match = re.search(pattern, first_line, re.IGNORECASE)
        if not match:
            print("‚ùå Pattern non riconosciuto nella prima riga")
            print("üîç Provo a estrarre manualmente...")
            
            # Estrazione manuale
            if '(' in first_line and ')' in first_line:
                # Trova le parentesi delle colonne
                col_start = first_line.find('(')
                col_end = first_line.find(')', col_start)
                columns_raw = first_line[col_start+1:col_end]
                
                # Trova le parentesi dei valori
                val_start = first_line.find('(', col_end)
                val_end = first_line.rfind(')')
                values_raw = first_line[val_start+1:val_end]
                
                print(f"üìã Colonne estratte: {columns_raw}")
                print(f"üìÑ Valori estratti: {values_raw[:100]}...")
            else:
                print("‚ùå Impossibile estrarre colonne e valori")
                return None
        else:
            columns_raw = match.group(1)
            values_raw = match.group(2)
        
        # Pulisci i nomi delle colonne
        columns = [col.strip() for col in columns_raw.split(',')]
        print(f"üìã Colonne ({len(columns)}): {columns}")
        
        # Funzione per parsare i valori con gestione avanzata delle virgolette
        def smart_split_values(values_string):
            values = []
            current = ""
            in_quotes = False
            quote_char = None
            parentheses_depth = 0
            i = 0
            
            while i < len(values_string):
                char = values_string[i]
                
                if not in_quotes:
                    if char == "'":
                        in_quotes = True
                        quote_char = char
                        current += char
                    elif char == '(':
                        parentheses_depth += 1
                        current += char
                    elif char == ')':
                        parentheses_depth -= 1
                        current += char
                    elif char == ',' and parentheses_depth == 0:
                        # Virgola al livello principale - nuovo valore
                        values.append(current.strip())
                        current = ""
                    else:
                        current += char
                else:
                    # Dentro le virgolette
                    if char == quote_char:
                        # Controlla se √® escaped
                        if i + 1 < len(values_string) and values_string[i + 1] == quote_char:
                            current += char + char
                            i += 1
                        else:
                            in_quotes = False
                            current += char
                            quote_char = None
                    else:
                        current += char
                
                i += 1
            
            # Aggiungi ultimo valore
            if current.strip():
                values.append(current.strip())
            
            return values
        
        # Elabora tutte le righe INSERT
        all_rows = []
        errors = 0
        
        for i, line in enumerate(insert_lines):
            try:
                # Estrai i valori dalla riga
                match = re.search(pattern, line, re.IGNORECASE)
                if match:
                    values_raw = match.group(2)
                else:
                    # Estrazione manuale di fallback
                    val_start = line.find('(', line.find('values'))
                    val_end = line.rfind(')')
                    if val_start != -1 and val_end != -1:
                        values_raw = line[val_start+1:val_end]
                    else:
                        errors += 1
                        continue
                
                # Parsa i valori
                values = smart_split_values(values_raw)
                
                # Pulisci i valori
                cleaned_values = []
                for val in values:
                    val = val.strip()
                    # Rimuovi virgolette esterne
                    if len(val) >= 2 and val.startswith("'") and val.endswith("'"):
                        val = val[1:-1].replace("''", "'")
                    cleaned_values.append(val)
                
                # Debug per le prime righe
                if i < 3:
                    print(f"üìÑ Riga {i+1}: {len(cleaned_values)} valori vs {len(columns)} colonne")
                    if len(cleaned_values) != len(columns):
                        print(f"    Valori: {cleaned_values}")
                
                if len(cleaned_values) == len(columns):
                    all_rows.append(cleaned_values)
                else:
                    errors += 1
                    
            except Exception as e:
                errors += 1
                if i < 5:  # Mostra errori solo per le prime righe
                    print(f"‚ùå Errore riga {i+1}: {str(e)}")
        
        print(f"‚úÖ Elaborate {len(all_rows)} righe, {errors} errori")
        
        if not all_rows:
            print("‚ùå Nessuna riga valida trovata")
            # Mostra un esempio di cosa ha trovato
            if insert_lines:
                print(f"üîç Esempio prima riga: {insert_lines[0]}")
            return None
        
        # Crea DataFrame
        df = pd.DataFrame(all_rows, columns=columns)
        return df
        
    except Exception as e:
        print(f"‚ùå Errore nel parsing SQL: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def sql_to_xlsx(sql_file_path, xlsx_file_path):
    """
    Converte un file SQL con INSERT statements in XLSX formattato
    """
    try:
        # Parsa il file SQL
        df = parse_sql_insert_file(sql_file_path)
        
        if df is None or df.empty:
            print("‚ùå Nessun dato da convertire")
            return False
        
        # Crea workbook Excel
        wb = Workbook()
        ws = wb.active
        ws.title = "EXPORT_TABLE"
        
        # Aggiungi dati al foglio
        for r in dataframe_to_rows(df, index=False, header=True):
            ws.append(r)
        
        # Applica formattazione
        apply_formatting(ws)
        
        # Formattazione speciale per colonne specifiche
        for col_num, col_name in enumerate(df.columns, 1):
            col_letter = ws.cell(row=1, column=col_num).column_letter
            
            # Formattazione per colonne numeriche (VALORE_QUOTE, etc.)
            if 'valore' in col_name.lower() or 'quote' in col_name.lower():
                for row in range(2, len(df) + 2):
                    cell = ws.cell(row=row, column=col_num)
                    if cell.value and str(cell.value).replace('.', '').replace(',', '').isdigit():
                        try:
                            cell.value = float(str(cell.value).replace(',', '.'))
                            cell.number_format = '#,##0.00'
                        except:
                            pass
            
            # Formattazione per date
            elif 'data' in col_name.lower():
                for row in range(2, len(df) + 2):
                    cell = ws.cell(row=row, column=col_num)
                    if cell.value:
                        cell.number_format = 'DD/MM/YYYY'
        
        # Salva file
        wb.save(xlsx_file_path)
        
        print(f"‚úÖ Conversione SQL completata!")
        print(f"üìÅ File salvato: {xlsx_file_path}")
        print(f"üìä Righe elaborate: {len(df)}")
        print(f"üìã Colonne: {len(df.columns)}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Errore durante la conversione SQL: {str(e)}")
        return False

def auto_detect_and_convert(input_file, output_file):
    """
    Rileva automaticamente il tipo di file e applica la conversione appropriata
    """
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            first_lines = f.read(1000).lower()
        
        if 'insert into' in first_lines and 'values' in first_lines:
            print("üìÑ Rilevato file SQL con INSERT statements")
            return sql_to_xlsx(input_file, output_file)
        elif '<?xml' in first_lines or '<' in first_lines:
            print("üìÑ Rilevato file XML")
            return xml_to_xlsx(input_file, output_file)
        else:
            print("‚ùå Formato file non riconosciuto")
            return False
            
    except Exception as e:
        print(f"‚ùå Errore nel rilevamento tipo file: {str(e)}")
        return False

# Esempio di utilizzo
if __name__ == "__main__":
    # Auto-rilevamento e conversione
    auto_detect_and_convert("export.xml", "output.xlsx")
    
    # Conversione SQL specifica
    # sql_to_xlsx("export.sql", "output_sql.xlsx")
    
    # Conversione XML classica
    # xml_to_xlsx("input.xml", "output_xml.xlsx")