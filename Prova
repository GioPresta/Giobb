Perfetto, grazie per la precisazione.

Ritorniamo alla struttura originale del tuo script, che:

1. Unisce tutti i file .txt


2. Estrae i blocchi dati


3. Pulisce e scrive Riepilogo.txt



Ora, manteniamo esattamente questo flusso, e aggiungiamo alla fine una fase extra che:

Prende Riepilogo.txt

Elimina le prime 3 righe

Applica la logica: nuova riga inizia quando una riga ha almeno 3 spazi all’inizio

Concatena le righe successive nella stessa riga come colonne

Salva tutto in Riepilogo_format.csv



---

✅ Script completo aggiornato (con flusso originale + nuova elaborazione finale)

import os

# === CONFIG ===
HEADER_LINES_TO_DELETE = ["LIVELLO", "ID", "OPERAZIONE"]
HEADERS_TO_DEDUPLICATE = ["GRAVITÀ", "ADESIONE", "ERRORE"]

# === ESTRAZIONE BLOCCHI ===
def estrai_blocco_dati(filepath):
    with open(filepath, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    blocco = []
    i = 0
    while i < len(righe) and 'LIVELLO' not in righe[i]:
        i += 1

    if i >= len(righe):
        return []

    i += 6  # Skip intestazioni
    while i < len(righe):
        riga = righe[i].strip()
        if riga.startswith('*'):
            break
        if not set(riga).issubset(set(' ')):
            blocco.append(righe[i])
        i += 1

    return blocco

# === PULIZIA TESTO ===
def pulisci_output(path_file):
    with open(path_file, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    pulite = []
    intestazioni_trovate = set()

    for riga in righe:
        testo = riga.strip()

        if not testo or testo.startswith('*') or set(testo).issubset(set(' ')):
            continue

        if any(testo.startswith(prefix) for prefix in HEADER_LINES_TO_DELETE):
            continue

        if any(testo.startswith(h) for h in HEADERS_TO_DEDUPLICATE):
            header = next(h for h in HEADERS_TO_DEDUPLICATE if testo.startswith(h))
            if header in intestazioni_trovate:
                continue
            intestazioni_trovate.add(header)

        pulite.append(riga)

    with open(path_file, 'w', encoding='latin-1') as f:
        f.writelines(pulite)

# === FORMATTA RIEPILOGO.TXT DOPO LA PULIZIA ===
def formatta_blocchi_da_testo(path_txt, output_csv, delimitatore='|'):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    # Elimina le prime 3 righe
    righe = righe[3:]

    righe_formattate = []
    riga_corrente = ''

    for riga in righe:
        testo = riga.rstrip('\n')

        if testo.startswith('   '):  # nuova riga tabellare
            if riga_corrente:
                righe_formattate.append(riga_corrente.strip())
            riga_corrente = testo
        else:
            riga_corrente += f'{delimitatore}{testo.strip()}'

    if riga_corrente:
        righe_formattate.append(riga_corrente.strip())

    with open(output_csv, 'w', encoding='utf-8') as f:
        for r in righe_formattate:
            f.write(r + '\n')

    print(f"✅ File CSV finale generato: {output_csv}")

# === MAIN ===
def main():
    cartella = os.path.dirname(os.path.abspath(__file__))
    nome_output_txt = "Riepilogo.txt"
    nome_output_csv = "Riepilogo_format.csv"
    percorso_txt = os.path.join(cartella, nome_output_txt)
    percorso_csv = os.path.join(cartella, nome_output_csv)

    # Fase 1: unisci tutti i .txt
    files_txt = sorted([
        f for f in os.listdir(cartella)
        if f.endswith('.txt') and f != nome_output_txt
    ])

    risultato = []
    for file in files_txt:
        blocco = estrai_blocco_dati(os.path.join(cartella, file))
        if blocco:
            risultato.extend(blocco)
            risultato.append('\n')

    with open(percorso_txt, 'w', encoding='latin-1') as f:
        f.writelines(risultato)

    # Fase 2: pulizia
    pulisci_output(percorso_txt)

    # Fase 3: formattazione finale per CSV
    formatta_blocchi_da_testo(percorso_txt, percorso_csv)

if __name__ == "__main__":
    main()


---

✅ Risultato

Riepilogo.txt: identico al flusso originale, ben pulito

Riepilogo_format.csv: righe coerenti con la logica che mi hai spiegato, pronte per Excel



---

Vuoi anche che aggiunga automaticamente le intestazioni delle colonne nel CSV finale (Riga, Messaggio1, Messaggio2, ...)? Posso farlo in 2 righe.

