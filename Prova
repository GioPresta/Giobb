Grazie mille per il feedback. Quindi:


---

‚ùóÔ∏èProblemi da risolvere:

1. Un contratto √® stato saltato
‚Üí probabilmente perch√© c‚Äô√® una riga di decorazione (es: ----) subito dopo le 6 righe di intestazione, e lo script la confonde come fine blocco o la fa saltare assieme a una riga utile


2. Dopo le 6 righe dell‚Äôintestazione, c‚Äô√® una riga piena di trattini che va completamente rimossa




---

‚úÖ Soluzione finale e solida

Prendiamo esattamente le 6 righe di intestazione (da LIVELLO)

Ignoriamo eventuali righe decorative subito dopo (es. ------)

Poi raccogliamo tutte le righe dati, fino al blocco *****

Non saltiamo righe solo perch√© sono dopo righe decorative



---

üßæ Codice aggiornato e risolutivo

import os
import re
import csv

inizio_tabella = re.compile(r'^\s*LIVELLO\b', re.IGNORECASE)
fine_tabella = re.compile(r'^\s*\*{5,}\s*$')
decorazioni = re.compile(r'^[\s\-\*=_\.]{4,}$')

header_lines = []
righe_dati = []
header_costruito = False

for nome_file in os.listdir():
    if nome_file.endswith('.txt') and not nome_file.startswith('riepilogo'):
        with open(nome_file, 'r', encoding='latin1') as f:
            lines = f.readlines()
            start_index = None

            # Trova la riga con "LIVELLO"
            for i, line in enumerate(lines):
                if inizio_tabella.match(line.strip()):
                    start_index = i
                    break

            if start_index is not None:
                # Prendi le 6 righe da "LIVELLO" in poi
                righe_intestazione = [lines[start_index + j].rstrip('\n') for j in range(6)]
                
                if not header_costruito:
                    header_lines = righe_intestazione
                    header_costruito = True

                # Dopo le 6 righe, salta eventuali righe decorative (come "--------")
                index_dati = start_index + 6
                while index_dati < len(lines) and decorazioni.match(lines[index_dati].strip()):
                    index_dati += 1

                # Ora leggi le righe dati fino alla riga con "*****"
                for line in lines[index_dati:]:
                    clean = line.strip()
                    if fine_tabella.match(clean):
                        break
                    if clean and not decorazioni.match(clean):
                        righe_dati.append(clean)

# Costruisce intestazioni combinando le 6 righe verticalmente
def crea_intestazioni(righe):
    splittate = [re.split(r'\s{2,}', r.strip()) for r in righe]
    max_col = max(len(r) for r in splittate)
    for r in splittate:
        while len(r) < max_col:
            r.append('')
    colonne = [' '.join(col).strip() for col in zip(*splittate)]
    return colonne

final_headers = crea_intestazioni(header_lines)

# Salva riepilogo.txt
with open('riepilogo.txt', 'w', encoding='utf-8') as f:
    for r in header_lines:
        f.write(r + '\n')
    for r in righe_dati:
        f.write(r + '\n')

# Salva riepilogo.csv
with open('riepilogo.csv', 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(final_headers)
    for r in righe_dati:
        valori = re.split(r'\s{2,}', r.strip())
        writer.writerow(valori)

print("‚úÖ Fatto! Tutti i contratti inclusi, intestazione unica, trattini rimossi.")


---

‚úÖ Con questo:

Le 6 righe di intestazione vengono prese una sola volta

Le righe di trattini subito dopo vengono saltate

Nessun contratto viene saltato

riepilogo.csv √® pronto per Excel con intestazioni corrette



---

Vuoi che ti indichi quali file hanno generato quali righe? Posso anche aggiungere una colonna col nome del file. Fammi sapere!

