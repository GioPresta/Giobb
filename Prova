Perfetto! Ecco lo script aggiornato in base alle tue nuove istruzioni:


---

‚úÖ Cosa fa ora lo script

1. Non inserisce pi√π la riga --- FILE: nomefile.txt ---.


2. Per il primo file:

Cerca la riga con LIVELLO.

Estrae quella e le 5 successive.

Salta le 4 righe dopo (totale salto: 10 righe compreso LIVELLO).

Poi copia tutto fino alla prima riga con *********, escludendo eventuali righe solo di trattini (-------).



3. Per i file successivi:

Salta le prime 10 righe totali (come sopra, includendo LIVELLO e le 4 da skippare).

Poi copia tutto fino agli asterischi, ignorando trattini.





---

üêç Script Python finale

import os

def process_file(filepath, include_header):
    with open(filepath, 'r', encoding='latin-1') as f:
        raw_lines = f.readlines()

    output = []
    i = 0
    found_header = False

    # Trova la riga con "LIVELLO"
    while i < len(raw_lines):
        if 'LIVELLO' in raw_lines[i]:
            found_header = True
            break
        i += 1

    if not found_header:
        return []

    header_start = i
    header_end = header_start + 6  # LIVELLO + 5
    data_start = header_end + 4    # skip 4 righe dopo intestazione

    if include_header:
        output.extend(raw_lines[header_start:header_end])

    # Estrai righe dati dopo salto iniziale
    i = data_start
    while i < len(raw_lines):
        line = raw_lines[i]
        if line.strip().startswith('***'):
            break
        if not set(line.strip()).issubset(set('-')):  # salta righe di trattini
            output.append(line)
        i += 1

    return output


def main():
    current_dir = os.path.dirname(os.path.abspath(__file__))
    txt_files = [f for f in os.listdir(current_dir) if f.endswith('.txt')]
    txt_files.sort()

    merged_output = []
    for idx, filename in enumerate(txt_files):
        filepath = os.path.join(current_dir, filename)
        include_header = idx == 0
        result = process_file(filepath, include_header)
        if result:
            merged_output.extend(result)
            merged_output.append('\n')

    output_path = os.path.join(current_dir, 'output_merged.txt')
    with open(output_path, 'w', encoding='utf-8') as out_f:
        out_f.writelines(merged_output)

    print(f'‚úÖ File creato: {output_path}')


if __name__ == "__main__":
    main()


---

üìå Cosa contiene output_merged.txt

Una sola intestazione (dal primo file).

Nessun nome file nel testo.

Tutti i dati estratti coerentemente, rispettando la tua logica.


Fammi sapere se vuoi:

Includere anche gli asterischi come punto finale.

Una versione .exe.

Scrivere direttamente su un file .csv.


Pronto all‚Äôuso!

