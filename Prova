Perfetto! Vuoi che lo script:

‚úÖ Prenda i .txt dalla stessa cartella dove si trova lo script stesso

‚úÖ Salvi riepilogo.txt e riepilogo.csv nella stessa cartella

‚ùå Non richieda nessun percorso da scrivere a mano


Ottimo. Ecco la versione finale e autonoma dello script:


---

üßæ Codice Python definitivo ‚Äì tutto automatico

import os
import re
import csv

# üìÇ Cartella dove si trova lo script stesso
cartella_input = os.path.dirname(os.path.abspath(__file__))

# Pattern riconoscimento struttura file
inizio_intestazione = re.compile(r'\bLIVELLO\b', re.IGNORECASE)
riga_asterischi = re.compile(r'^\*{5,}$')
riga_decorativa = re.compile(r'^[-\s]{10,}$')

header_lines = []
righe_dati = []
intestazione_salvata = False

def apri_file(path):
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.readlines()
    except UnicodeDecodeError:
        with open(path, 'r', encoding='latin1') as f:
            return f.readlines()

# Elenco dei .txt nella cartella dello script
file_txt = [f for f in os.listdir(cartella_input) if f.endswith('.txt') and not f.startswith('riepilogo')]

if not file_txt:
    print("‚ùå Nessun file .txt trovato nella cartella:", cartella_input)
    exit()

for nome_file in file_txt:
    percorso_file = os.path.join(cartella_input, nome_file)
    lines = apri_file(percorso_file)

    start_index = None
    for i, line in enumerate(lines):
        if inizio_intestazione.search(line.strip()):
            start_index = i
            break
    else:
        continue  # se non trova "LIVELLO", salta il file

    # Salva una sola volta le 6 righe di intestazione
    if not intestazione_salvata:
        header_lines = [lines[start_index + j].rstrip('\n') for j in range(6)]
        intestazione_salvata = True

    # Salta 4 righe decorative dopo intestazione
    index = start_index + 10

    # Raccoglie i dati (righe tra trattini e asterischi)
    for line in lines[index:]:
        riga = line.strip()
        if riga_asterischi.match(riga):
            break
        if riga:
            righe_dati.append(riga)

# Combina verticalmente le 6 righe di intestazione in colonne CSV
def crea_colonne_da_header(righe):
    split = [re.split(r'\s{2,}', r.strip()) for r in righe]
    max_col = max(len(r) for r in split)
    for r in split:
        while len(r) < max_col:
            r.append('')
    return [' '.join(col).strip() for col in zip(*split)]

final_headers = crea_colonne_da_header(header_lines)

# Salva riepilogo.txt
path_txt = os.path.join(cartella_input, 'riepilogo.txt')
with open(path_txt, 'w', encoding='utf-8') as f:
    for r in header_lines:
        f.write(r + '\n')
    for r in righe_dati:
        f.write(r + '\n')

# Salva riepilogo.csv
path_csv = os.path.join(cartella_input, 'riepilogo.csv')
with open(path_csv, 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(final_headers)
    for r in righe_dati:
        valori = re.split(r'\s{2,}', r.strip())
        writer.writerow(valori)

print(f"‚úÖ Fatti! File letti: {len(file_txt)}")
print(f"üìÑ Contratti totali estratti: {len(righe_dati)}")
print(f"üìù Salvati in: {path_txt}")
print(f"üìä Salvati in: {path_csv}")


---

‚úÖ Ora fa tutto da solo

Nessun percorso da scrivere

Basta mettere lo script .py insieme ai file .txt

Eseguire lo script ‚Üí crea riepilogo.txt e riepilogo.csv nella stessa cartella



---

Se vuoi anche:

aprire il file automaticamente dopo la creazione

aggiungere il nome del file origine come colonna


‚Ä¶posso aggiungerlo al volo. Ma cos√¨ sei operativo al 100%.

