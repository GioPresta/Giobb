Grazie. Ora non ci sono più dubbi.


---

✅ Struttura esatta di ogni file:

1. 6 righe di intestazione → da salvare una volta sola


2. 4 righe di trattini → da ignorare


3. 1 o più righe di dati (le polizze) → da raccogliere tutte


4. riga di asterischi (*****) → da fermare la lettura



E tutti i file .txt seguono questa struttura identica.


---

🧾 Codice finale – rispetta esattamente questa sequenza

import os
import re
import csv

# Pattern per individuare blocchi
inizio_intestazione = re.compile(r'\bLIVELLO\b', re.IGNORECASE)
riga_asterischi = re.compile(r'^\*{5,}$')
riga_decorativa = re.compile(r'^[-\s]{10,}$')

# Per salvare
header_lines = []
righe_dati = []
intestazione_salvata = False

for nome_file in os.listdir():
    if nome_file.endswith('.txt') and not nome_file.startswith('riepilogo'):
        with open(nome_file, 'r', encoding='latin1') as f:
            lines = f.readlines()

            # Cerca la riga "LIVELLO"
            for i, line in enumerate(lines):
                if inizio_intestazione.search(line.strip()):
                    start_index = i
                    break
            else:
                continue  # Se non trova LIVELLO, salta file

            # Prendi le 6 righe di intestazione
            intestazione = [lines[start_index + j].rstrip('\n') for j in range(6)]

            if not intestazione_salvata:
                header_lines = intestazione
                intestazione_salvata = True

            # Salta le 4 righe di trattini subito dopo
            index = start_index + 10

            # Ora leggi i dati fino agli asterischi
            for line in lines[index:]:
                riga = line.strip()
                if riga_asterischi.match(riga):
                    break
                if riga:  # se non è vuota
                    righe_dati.append(riga)

# Funzione per combinare le 6 righe in intestazioni verticali
def crea_colonne_da_header(righe):
    split = [re.split(r'\s{2,}', r.strip()) for r in righe]
    max_col = max(len(r) for r in split)
    for r in split:
        while len(r) < max_col:
            r.append('')
    return [' '.join(col).strip() for col in zip(*split)]

# Costruzione colonne
final_headers = crea_colonne_da_header(header_lines)

# Scrittura riepilogo.txt
with open('riepilogo.txt', 'w', encoding='utf-8') as f:
    for r in header_lines:
        f.write(r + '\n')
    for r in righe_dati:
        f.write(r + '\n')

# Scrittura riepilogo.csv
with open('riepilogo.csv', 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(final_headers)
    for r in righe_dati:
        valori = re.split(r'\s{2,}', r.strip())
        writer.writerow(valori)

print("✅ Fatto! Tutti i file elaborati con struttura esatta.")


---

✅ Cosa garantisce:

6 righe prese da ogni file? ❌ No. Solo dal primo file.

4 righe di trattini? ✅ Ignorate sempre.

Riga *****? ✅ Serve da stop.

Righe dati? ✅ Nessuna viene saltata.



---

Vuoi anche sapere da quale file viene ogni riga dati? Posso aggiungere una colonna "FONTE". Ma con questo script, il tuo formato è gestito al 100%.
