import os
import sys
import glob
import threading
import datetime
import traceback
import customtkinter as ctk
from tkinter import filedialog, messagebox
import pandas as pd
import warnings

# Suppress warnings
pd.options.mode.chained_assignment = None
warnings.filterwarnings("ignore")

# Directory setup
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
MAINS_DIR = os.path.dirname(CURRENT_DIR)
PROJECT_ROOT = os.path.dirname(MAINS_DIR)
SOURCES_DIR = os.path.join(PROJECT_ROOT, "Sources")
INPUTS_DIR = os.path.join(PROJECT_ROOT, "Inputs")
RESULTS_DIR = os.path.join(PROJECT_ROOT, "results", "AssetPricing_results")

os.makedirs(INPUTS_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)

if SOURCES_DIR not in sys.path:
    sys.path.append(SOURCES_DIR)

def valuation_date_default():
    """Calculate default valuation date (31/12 of previous year)"""
    today = datetime.date.today()
    return f"{today.year - 1}-12-31"

def find_first(pattern):
    """Find first file matching pattern in INPUTS_DIR"""
    matches = sorted(glob.glob(os.path.join(INPUTS_DIR, pattern)))
    return matches[0] if matches else ""

def shorten_path(full_path):
    """Show filename with modification date"""
    if not full_path:
        return ""
    try:
        mtime = os.path.getmtime(full_path)
        date_str = datetime.datetime.fromtimestamp(mtime).strftime("%d/%m/%Y %H:%M")
        return f"{os.path.basename(full_path)} ({date_str})"
    except:
        return os.path.basename(full_path)

# CustomTkinter theme
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Asset Pricing CARDIF - Repricing Sensi 3.13.7")
        self.geometry("1000x700")
        self.resizable(False, False)

        # Window icon
        icon_path = os.path.join(INPUTS_DIR, "bnp.ico")
        if os.path.exists(icon_path):
            try:
                self.iconbitmap(default=icon_path)
            except:
                pass

        # Variables
        self.assets_dataset_path = ctk.StringVar()
        self.assets_dataset_path_display = ctk.StringVar()
        self.spot_curve_path = ctk.StringVar()
        self.spot_curve_path_display = ctk.StringVar()
        self.spread_input_path = ctk.StringVar()
        self.spread_input_path_display = ctk.StringVar()
        self.inflation_index_path = ctk.StringVar()
        self.inflation_index_path_display = ctk.StringVar()
        self.output_directory = ctk.StringVar(value=RESULTS_DIR)
        self.output_directory_display = ctk.StringVar(value=shorten_path(RESULTS_DIR))

        self.valuation_date = ctk.StringVar(value=valuation_date_default())
        self.spread_up = ctk.StringVar(value="0.5")
        self.spread_down = ctk.StringVar(value="0.5")
        self.ufr = ctk.StringVar(value="3.3")

        self.container = ctk.CTkFrame(self, corner_radius=12)
        self.container.pack(fill="both", expand=True, padx=1, pady=1)

        self._build_ui()
        self.autofill_inputs()

    def _build_ui(self):
        # Header: title
        title_frame = ctk.CTkFrame(self.container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 6))

        title_label = ctk.CTkLabel(
            title_frame,
            text="Asset Pricing CARDIF — Repricing Sensi 3.13.7",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title_label.pack(side="left", pady=5)

        # Form card
        form_card = ctk.CTkFrame(self.container, corner_radius=12, fg_color="#1b1f24")
        form_card.pack(fill="both", expand=True, padx=10, pady=(0, 2))
        form_card.grid_columnconfigure(0, weight=1)
        form_card.grid_columnconfigure(1, weight=3)
        form_card.grid_columnconfigure(2, weight=0)

        # Input files
        file_rows = [
            ("Asset tool file", self.assets_dataset_path, self.assets_dataset_path_display),
            ("Spot curve central", self.spot_curve_path, self.spot_curve_path_display),
            ("Spreads floating assets", self.spread_input_path, self.spread_input_path_display),
            ("Inflation index", self.inflation_index_path, self.inflation_index_path_display),
        ]

        for idx, (label_text, var, display_var) in enumerate(file_rows):
            ctk.CTkLabel(form_card, text=label_text, anchor="w").grid(
                row=idx, column=0, sticky="w", padx=5, pady=2
            )
            ctk.CTkEntry(
                form_card,
                textvariable=display_var,
                state="readonly",
                fg_color="#3a3f44"
            ).grid(row=idx, column=1, sticky="ew", padx=5, pady=2)
            ctk.CTkButton(
                form_card,
                text="Browse",
                width=90,
                fg_color="#00A678",
                hover=True,
                command=lambda v=var, d=display_var: self.browse_file(v, d)
            ).grid(row=idx, column=2, padx=5, pady=2)

        pr = 4

        # Valuation date
        ctk.CTkLabel(form_card, text="Valuation date (YYYY-MM-DD)", anchor="w").grid(
            row=pr, column=0, sticky="w", padx=5, pady=2
        )
        ctk.CTkEntry(form_card, textvariable=self.valuation_date).grid(
            row=pr, column=1, sticky="ew", padx=5, pady=2
        )

        # Spread up
        ctk.CTkLabel(form_card, text="Spread up", anchor="w").grid(
            row=pr + 1, column=0, sticky="w", padx=5, pady=2
        )
        ctk.CTkEntry(form_card, textvariable=self.spread_up).grid(
            row=pr + 1, column=1, sticky="ew", padx=5, pady=2
        )

        # Spread down
        ctk.CTkLabel(form_card, text="Spread down", anchor="w").grid(
            row=pr + 2, column=0, sticky="w", padx=5, pady=2
        )
        ctk.CTkEntry(form_card, textvariable=self.spread_down).grid(
            row=pr + 2, column=1, sticky="ew", padx=5, pady=2
        )

        # UFR
        ctk.CTkLabel(form_card, text="UFR (%)", anchor="w").grid(
            row=pr + 3, column=0, sticky="w", padx=5, pady=2
        )
        ctk.CTkEntry(form_card, textvariable=self.ufr).grid(
            row=pr + 3, column=1, sticky="ew", padx=5, pady=2
        )

        # Output directory
        ctk.CTkLabel(form_card, text="Output directory", anchor="w").grid(
            row=pr + 4, column=0, sticky="w", padx=5, pady=2
        )
        ctk.CTkEntry(
            form_card,
            textvariable=self.output_directory_display,
            state="readonly",
            fg_color="#3a3f44"
        ).grid(row=pr + 4, column=1, sticky="ew", padx=5, pady=2)
        ctk.CTkButton(
            form_card,
            text="Browse",
            width=90,
            fg_color="#00A678",
            hover=True,
            command=self.choose_output
        ).grid(row=pr + 4, column=2, padx=5, pady=2)

        # Frame for run button and log
        run_frame = ctk.CTkFrame(self.container, fg_color="transparent")
        run_frame.pack(fill="x", padx=10, pady=(2, 2))

        self.run_btn = ctk.CTkButton(
            run_frame,
            text="Run Script",
            fg_color="#00A678",
            hover=True,
            command=self.run_script_thread
        )
        self.run_btn.pack(fill="x", pady=(0, 2))

        self.log_label = ctk.CTkLabel(run_frame, text="", anchor="w")
        self.log_label.pack(fill="x", pady=(0, 0))

    # ----------------------
    # Helpers
    # ----------------------
    def browse_file(self, var, display_var):
        p = filedialog.askopenfilename(
            initialdir=INPUTS_DIR,
            filetypes=[("Excel files", "*.xlsx;*.xls")]
        )
        if p:
            var.set(p)
            display_var.set(shorten_path(p))

    def choose_output(self):
        p = filedialog.askdirectory(initialdir=RESULTS_DIR)
        if p:
            self.output_directory.set(p)
            self.output_directory_display.set(shorten_path(p))

    def autofill_inputs(self):
        """Auto-fill input fields with files matching patterns"""
        self.assets_dataset_path.set(find_first("Asset_tool_*.xlsx"))
        self.spot_curve_path.set(find_first("Spot_curve_central_*.xlsx"))
        self.spread_input_path.set(find_first("Spreads_tasso_variabile_*.xlsx"))
        self.inflation_index_path.set(find_first("inflation_index_*.xlsx"))

        self.assets_dataset_path_display.set(shorten_path(self.assets_dataset_path.get()))
        self.spot_curve_path_display.set(shorten_path(self.spot_curve_path.get()))
        self.spread_input_path_display.set(shorten_path(self.spread_input_path.get()))
        self.inflation_index_path_display.set(shorten_path(self.inflation_index_path.get()))
        self.output_directory_display.set(shorten_path(self.output_directory.get()))

    def validate_inputs(self):
        try:
            datetime.datetime.strptime(self.valuation_date.get(), "%Y-%m-%d")
            float(self.spread_up.get())
            float(self.spread_down.get())
            float(self.ufr.get())
        except:
            messagebox.showerror("Error", "Check date and numeric fields")
            return False
        if not self.assets_dataset_path.get() or not self.spot_curve_path.get():
            messagebox.showerror("Error", "Required files missing")
            return False
        return True

    def run_script_thread(self):
        if not self.validate_inputs():
            return
        self.run_btn.configure(state="disabled")
        self.log_label.configure(text="Running…")
        t = threading.Thread(target=self.run_script, daemon=True)
        t.start()

    def run_script(self):
        try:
            os.chdir(PROJECT_ROOT)
            from AssetPricingSource.Options import Options
            from AssetPricingSource.Executor import Executor
            from AssetPricingSource.Initializer import Initializer
            from AssetPricingSource.Reader import Reader
            from AssetPricingSource.PostProcessing import PostProcessing
            from AssetPricingSource.Writer import Writer
            from AssetPricingSource.SmithWilsonModel import SmithWilsonModel

            options = Options(
                assets_dataset_path=self.assets_dataset_path.get(),
                yearly_spot_rates_curve_path=self.spot_curve_path.get(),
                spread_input_path=self.spread_input_path.get(),
                inflation_index_path=self.inflation_index_path.get(),
                yearly_shocked_spot_rates_curve_path="",
                valuation_date=self.valuation_date.get(),
                curves_by_rating="",
                sensitivity_risk="Interest",
                spread_up=float(self.spread_up.get()),
                spread_down=float(self.spread_down.get()),
                UFR=float(self.ufr.get()) / 100.0,
                output_directory=self.output_directory.get()
            )

            initializer = Initializer(options)
            smith_wilson_model = SmithWilsonModel(options)
            reader = Reader(options, smith_wilson_model)
            post_processing = PostProcessing(options)
            writer = Writer(options)

            Executor(options, initializer, reader, post_processing, writer).run()
            self.log_label.configure(text="Script executed successfully")
        except:
            traceback.print_exc()
            self.log_label.configure(text="Error occurred")
        finally:
            self.run_btn.configure(state="normal")


if __name__ == "__main__":
    app = App()
    app.mainloop()