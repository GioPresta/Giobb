Perfetto, questa Ã¨ una richiesta piÃ¹ raffinata, e la logica Ã¨ molto chiara. Riassumo la nuova specifica e poi ti fornisco il blocco Python completo aggiornato per la formattazione CSV.


---

âœ… Specifiche aggiornate

1. Salta le prime 3 righe del file.


2. Una riga inizia una nuova riga nel CSV solo se inizia con esattamente 3 spazi ('   ').


3. Le righe successive (senza 3 spazi iniziali) sono continuazioni della riga precedente (colonne aggiuntive).


4. Le colonne allâ€™interno di una riga vengono suddivise secondo questa logica:

Se ci sono 4 o piÃ¹ spazi consecutivi, Ã¨ fine colonna.

Se ci sono numeri separati da almeno 1 spazio, sono colonne separate.

Lettere + spazio singolo â†’ non separare (appartengono alla stessa colonna).



5. Il separatore nel CSV sarÃ  il punto e virgola ;.




---

ðŸ”§ Blocco Python aggiornato (per il CSV)

import re

def formatta_blocchi_da_testo(path_txt, output_csv):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    righe = righe[3:]  # Salta prime 3 righe

    righe_formattate = []
    riga_corrente = []

    def splitta_colonne(riga):
        riga = riga.strip()

        # Prima: split forte su 4 o piÃ¹ spazi
        blocchi = re.split(r'\s{4,}', riga)
        colonne = []

        for blocco in blocchi:
            # Poi, dentro ogni blocco, se contiene numeri separati da spazi, spezza ulteriormente
            parole = blocco.split()
            temp = []
            i = 0
            while i < len(parole):
                parola = parole[i]
                if parola.isdigit():
                    colonne.append(parola)
                else:
                    # Verifica se la parola corrente + la prossima formano un numero o descrizione
                    if i + 1 < len(parole) and parole[i + 1].isdigit():
                        colonne.append(parola)
                        colonne.append(parole[i + 1])
                        i += 1
                    else:
                        temp.append(parola)
                i += 1
            if temp:
                colonne.append(' '.join(temp))
        return colonne

    for riga in righe:
        testo = riga.rstrip('\n')

        if testo.startswith('   ') and not testo.startswith('    '):  # nuova riga
            if riga_corrente:
                righe_formattate.append(';'.join(riga_corrente))
            riga_corrente = splitta_colonne(testo)
        else:
            riga_corrente.extend(splitta_colonne(testo))

    if riga_corrente:
        righe_formattate.append(';'.join(riga_corrente))

    with open(output_csv, 'w', encoding='utf-8') as f:
        for r in righe_formattate:
            f.write(r + '\n')

    print(f"âœ… CSV formattato generato: {output_csv}")


---

ðŸ’¡ Esempi di parsing

Riga:

3    000000001      12345678   Codice errore        ALTRO TESTO

â†’ diventa:

3;000000001;12345678;Codice errore;ALTRO TESTO


---

ðŸ“Œ Come integrarlo

Nel tuo main() esistente, dopo:

pulisci_output(percorso_txt)

Aggiungi:

formatta_blocchi_da_testo(percorso_txt, percorso_csv)


---

Fammi sapere se vuoi anche:

forzare un numero fisso di colonne

inserire intestazioni in prima riga del CSV

trattare eccezioni specifiche (es. codici polizza, matricole, ecc.)


Ti preparo il modulo su misura.

