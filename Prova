Perfetto! Ti fornisco ora uno script unico che:

1. Legge tutti i file .txt nella cartella (escluso Riepilogo.txt)


2. Estrae i blocchi dati dopo lâ€™intestazione (LIVELLO, ID, ecc.)


3. Rimuove righe vuote, intestazioni duplicate e righe da eliminare


4. Scrive un file Riepilogo.txt


5. Elimina le prime 3 righe


6. Ristruttura i dati in righe tabellari basandosi sullâ€™indentazione con 3 spazi


7. Scrive un file finale Riepilogo_format.csv apribile in Excel




---

âœ… Script unico completo (merge_formatta.py)

import os
import csv

# === CONFIGURAZIONI ===
HEADER_LINES_TO_DELETE = ["LIVELLO", "ID", "OPERAZIONE"]
HEADERS_TO_DEDUPLICATE = ["GRAVITÃ€", "ADESIONE", "ERRORE"]

# === ESTRAI DATI DAI FILE .TXT ===
def estrai_blocco_dati(filepath):
    with open(filepath, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    blocco = []
    i = 0
    while i < len(righe) and 'LIVELLO' not in righe[i]:
        i += 1

    if i >= len(righe):
        return []

    i += 6  # salta intestazioni
    while i < len(righe):
        riga = righe[i].strip()
        if riga.startswith('*'):
            break
        if not set(riga).issubset(set(' ')):
            blocco.append(righe[i])
        i += 1

    return blocco

# === PULISCI FILE DI OUTPUT ===
def pulisci_output(path_file):
    with open(path_file, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    pulite = []
    intestazioni_trovate = set()

    for riga in righe:
        testo = riga.strip()

        if not testo or testo.startswith('*') or set(testo).issubset(set(' ')):
            continue

        if any(testo.startswith(prefix) for prefix in HEADER_LINES_TO_DELETE):
            continue

        if any(testo.startswith(h) for h in HEADERS_TO_DEDUPLICATE):
            header = next(h for h in HEADERS_TO_DEDUPLICATE if testo.startswith(h))
            if header in intestazioni_trovate:
                continue
            intestazioni_trovate.add(header)

        pulite.append(riga)

    with open(path_file, 'w', encoding='latin-1') as f:
        f.writelines(pulite)

# === FORMATTA E CONVERTI IN CSV ===
def formatta_blocchi_da_testo(path_txt, output_csv, delimitatore='|'):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    # Elimina le prime 3 righe
    righe = righe[3:]

    righe_formattate = []
    riga_corrente = ''

    for riga in righe:
        testo = riga.rstrip('\n')

        if testo.startswith('   '):  # Nuova riga tabellare
            if riga_corrente:
                righe_formattate.append(riga_corrente.strip())
            riga_corrente = testo
        else:
            riga_corrente += f'{delimitatore}{testo.strip()}'

    if riga_corrente:
        righe_formattate.append(riga_corrente.strip())

    with open(output_csv, 'w', encoding='utf-8') as f:
        for r in righe_formattate:
            f.write(r + '\n')

    print(f"âœ… File CSV finale generato: {output_csv}")

# === MAIN ===
def main():
    cartella = os.path.dirname(os.path.abspath(__file__))
    nome_output_txt = "Riepilogo.txt"
    nome_output_csv = "Riepilogo_format.csv"
    percorso_txt = os.path.join(cartella, nome_output_txt)
    percorso_csv = os.path.join(cartella, nome_output_csv)

    # Unisci i .txt
    files_txt = sorted([
        f for f in os.listdir(cartella)
        if f.endswith('.txt') and f != nome_output_txt
    ])

    risultato = []
    for file in files_txt:
        blocco = estrai_blocco_dati(os.path.join(cartella, file))
        if blocco:
            risultato.extend(blocco)
            risultato.append('\n')

    with open(percorso_txt, 'w', encoding='latin-1') as f:
        f.writelines(risultato)

    pulisci_output(percorso_txt)
    formatta_blocchi_da_testo(percorso_txt, percorso_csv)

if __name__ == "__main__":
    main()


---

ðŸ“‚ Output

Riepilogo.txt â†’ file unificato e pulito

Riepilogo_format.csv â†’ file con righe tabellari, delimitate con | (apribile in Excel con "Importa > delimitato da pipe")



---

Hai tutto pronto. Vuoi che aggiunga intestazioni al CSV? Oppure usare ; o \t come delimitatore per compatibilitÃ  migliore con Excel?

