Perfetto, grazie! Ora √® ultra-preciso ‚úÖ


---

‚úÖ Aggiornamento finale:

Dopo le 6 righe di intestazione, ci sono sempre esattamente 4 righe di trattini che devono essere:

> ‚ùå completamente ignorate
‚úÖ non fanno parte n√© dell‚Äôintestazione n√© dei dati




---

üßæ Codice finale aggiornato con rimozione esatta delle 4 righe di trattini

import os
import re
import csv

# Riconosce blocchi
inizio_intestazione = re.compile(r'^\s*LIVELLO\b', re.IGNORECASE)
riga_asterischi = re.compile(r'^\*{5,}$')

header_lines = []
final_headers = []
righe_dati = []
intestazione_salvata = False

for nome_file in os.listdir():
    if nome_file.endswith('.txt') and not nome_file.startswith('riepilogo'):
        with open(nome_file, 'r', encoding='latin1') as f:
            lines = f.readlines()
            start_index = None

            # Trova la riga con LIVELLO
            for i, line in enumerate(lines):
                if inizio_intestazione.match(line.strip()):
                    start_index = i
                    break

            if start_index is not None:
                # Salva le 6 righe di intestazione solo una volta
                if not intestazione_salvata:
                    header_lines = [lines[start_index + j].rstrip('\n') for j in range(6)]
                    intestazione_salvata = True

                # Salta le 6 righe + le 4 successive (i trattini)
                index_dati = start_index + 10

                # Leggi le righe dati fino agli asterischi
                for line in lines[index_dati:]:
                    clean = line.strip()
                    if riga_asterischi.match(clean):
                        break
                    if clean:
                        righe_dati.append(clean)

# Unisce le intestazioni verticalmente (6 righe in colonne)
def crea_intestazioni_verticali(righe):
    split = [re.split(r'\s{2,}', r.strip()) for r in righe]
    max_col = max(len(r) for r in split)
    for r in split:
        while len(r) < max_col:
            r.append('')
    return [' '.join(col).strip() for col in zip(*split)]

final_headers = crea_intestazioni_verticali(header_lines)

# Scrive riepilogo.txt
with open('riepilogo.txt', 'w', encoding='utf-8') as f:
    for r in header_lines:
        f.write(r + '\n')
    for r in righe_dati:
        f.write(r + '\n')

# Scrive riepilogo.csv
with open('riepilogo.csv', 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(final_headers)
    for r in righe_dati:
        valori = re.split(r'\s{2,}', r.strip())
        writer.writerow(valori)

print("‚úÖ Fatto! 6 righe di intestazione + dati reali. 4 righe di trattini rimosse correttamente.")


---

‚úÖ Ora fa esattamente questo:

üîπ Prende 6 righe (da LIVELLO in gi√π)

‚ùå Salta le 4 righe di trattini

‚úÖ Prende tutte le righe successive (fino agli *****)

‚ùå Ignora gli *****

‚úÖ Scrive tutto in riepilogo.txt e riepilogo.csv con intestazioni perfette



---

Vuoi che aggiunga la colonna con il nome del file origine per ogni riga? Posso farlo in un attimo!

