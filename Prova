import os
import sys
import glob
import threading
import datetime
import traceback
import warnings
import customtkinter as ctk
from tkinter import filedialog, messagebox
import pandas as pd

# ------------------------
# Setup warnings & paths
# ------------------------
pd.options.mode.chained_assignment = None
warnings.filterwarnings("ignore")

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
MAINS_DIR = os.path.dirname(CURRENT_DIR)
PROJECT_ROOT = os.path.dirname(MAINS_DIR)
SOURCES_DIR = os.path.join(PROJECT_ROOT, "Sources")
INPUTS_DIR = os.path.join(PROJECT_ROOT, "Inputs")
RESULTS_DIR = os.path.join(PROJECT_ROOT, "results", "AssetPricing_results")
LOGO_DIR = os.path.join(PROJECT_ROOT, "logo")

os.makedirs(INPUTS_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)

if SOURCES_DIR not in sys.path:
    sys.path.append(SOURCES_DIR)

# ------------------------
# Helper functions
# ------------------------
def valuation_date_default():
    today = datetime.date.today()
    current_quarter = (today.month - 1) // 3 + 1
    if current_quarter == 1:
        year = today.year - 1
        month = 12
    else:
        year = today.year
        month = (current_quarter - 1) * 3
    return f"{year}-{month:02d}-30"

def shorten_path(full_path):
    if not full_path:
        return ""
    try:
        mtime = os.path.getmtime(full_path)
        date_str = datetime.datetime.fromtimestamp(mtime).strftime("%d/%m/%Y %H:%M")
        return f"{os.path.basename(full_path)} ({date_str})"
    except:
        return os.path.basename(full_path)

def get_prev_quarter_files(quarter_selected, year_selected):
    """
    Restituisce dizionario dei file del trimestre precedente rispetto a quello selezionato
    """
    prev_quarter = quarter_selected - 1 if quarter_selected > 1 else 4
    prev_year = year_selected if quarter_selected > 1 else year_selected - 1
    yy = str(prev_year)[-2:]

    files = {}
    patterns = {
        "assets_dataset": f"Asset_tool_Q{prev_quarter}{yy}_BCC*.xlsx",
        "spot_curve": f"Spot_curve_central_Q{prev_quarter}{yy}_no_va*.xlsx",
        "spread_input": f"Spreads_tasso_variabile_Q{prev_quarter}{yy}*.xlsx",  # senza underscore
        "inflation_index": f"inflation_index_Q{prev_quarter}{yy}*.xlsx"       # senza underscore
    }

    for key, pat in patterns.items():
        matches = [f for f in glob.glob(os.path.join(INPUTS_DIR, pat)) if "_appoggio" not in os.path.basename(f)]
        if matches:
            matches.sort(key=lambda f: os.path.getmtime(f), reverse=True)
            files[key] = matches[0]
        else:
            files[key] = ""
    return files

# ------------------------
# GUI
# ------------------------
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Asset Pricing BCC - Repricing Sensi 3.13.7")
        self.geometry("900x580")
        self.resizable(False, False)

        # Window icon
        icon_path = os.path.join(LOGO_DIR, "bnp.ico")
        if os.path.exists(icon_path):
            try:
                self.iconbitmap(default=icon_path)
            except:
                pass

        self.report_callback_exception = self.gui_exception_handler

        # Variables
        self.assets_dataset_path = ctk.StringVar()
        self.assets_dataset_path_display = ctk.StringVar()
        self.spot_curve_path = ctk.StringVar()
        self.spot_curve_path_display = ctk.StringVar()
        self.spread_input_path = ctk.StringVar()
        self.spread_input_path_display = ctk.StringVar()
        self.inflation_index_path = ctk.StringVar()
        self.inflation_index_path_display = ctk.StringVar()
        self.output_directory = ctk.StringVar(value=RESULTS_DIR)
        self.output_directory_display = ctk.StringVar(value=shorten_path(RESULTS_DIR))

        self.valuation_date = ctk.StringVar(value=valuation_date_default())
        self.spread_up = ctk.StringVar(value="0.5")
        self.spread_down = ctk.StringVar(value="0.5")
        self.ufr = ctk.StringVar(value="3.3")

        today = datetime.date.today()
        self.selected_quarter = ctk.StringVar(value=f"Q{(today.month - 1)//3 +1}")
        self.selected_year = ctk.StringVar(value=str(today.year))

        self.container = ctk.CTkFrame(self, corner_radius=12)
        self.container.pack(fill="both", expand=True, padx=5, pady=5)

        self._build_ui()
        self.autofill_inputs()

    # ------------------------
    # Build GUI
    # ------------------------
    def _build_ui(self):
        # Titolo
        title_label = ctk.CTkLabel(
            self.container,
            text="Asset Pricing BCC - Repricing Sensi 3.13.7",
            font=ctk.CTkFont(size=22, weight="bold"),
            anchor="w"
        )
        title_label.pack(fill="x", pady=(0,5), padx=5)

        # Card principale
        form_card = ctk.CTkFrame(self.container, corner_radius=12, fg_color="#1b1f24")
        form_card.pack(fill="both", expand=True, padx=5, pady=0)
        form_card.grid_columnconfigure(0, weight=1)
        form_card.grid_columnconfigure(1, weight=3)
        form_card.grid_columnconfigure(2, weight=0)

        # Input file rows
        file_rows = [
            ("Asset dataset", self.assets_dataset_path, self.assets_dataset_path_display),
            ("Spot curve central", self.spot_curve_path, self.spot_curve_path_display),
            ("Spread input", self.spread_input_path, self.spread_input_path_display),
            ("Inflation index", self.inflation_index_path, self.inflation_index_path_display),
        ]
        for idx, (label_text, var, display_var) in enumerate(file_rows):
            ctk.CTkLabel(form_card, text=label_text, anchor="w").grid(
                row=idx, column=0, sticky="w", padx=2, pady=0
            )
            ctk.CTkEntry(form_card, textvariable=display_var, state="readonly", fg_color="#3a3f44").grid(
                row=idx, column=1, sticky="ew", padx=2, pady=0
            )
            ctk.CTkButton(form_card, text="Browse", width=80, fg_color="#00A678", hover=True,
                           command=lambda v=var, d=display_var: self.browse_file(v,d)).grid(row=idx, column=2, padx=2, pady=0)

        pr = 4

        # Valutazione numerica
        validate_numeric = (self.register(lambda P: all(c.isdigit() or c == "." for c in P)), "%P")

        # Valuation Date rigidamente YYYY-MM-DD
        def validate_valuation_date(P):
            if len(P) > 10:
                return False
            for i, c in enumerate(P):
                if i in [4,7]:
                    if c != "-":
                        return False
                else:
                    if not c.isdigit():
                        return False
            return True
        vcmd_date = self.register(validate_valuation_date)

        # Form fields
        ctk.CTkLabel(form_card, text="Valuation date (YYYY-MM-DD)", anchor="w").grid(row=pr, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkEntry(form_card, textvariable=self.valuation_date, validate="key", validatecommand=(vcmd_date, "%P")).grid(row=pr, column=1, sticky="ew", padx=2, pady=0)

        ctk.CTkLabel(form_card, text="Spread up", anchor="w").grid(row=pr+1, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkEntry(form_card, textvariable=self.spread_up, validate="key", validatecommand=validate_numeric).grid(row=pr+1, column=1, sticky="ew", padx=2, pady=0)

        ctk.CTkLabel(form_card, text="Spread down", anchor="w").grid(row=pr+2, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkEntry(form_card, textvariable=self.spread_down, validate="key", validatecommand=validate_numeric).grid(row=pr+2, column=1, sticky="ew", padx=2, pady=0)

        ctk.CTkLabel(form_card, text="UFR (%)", anchor="w").grid(row=pr+3, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkEntry(form_card, textvariable=self.ufr, validate="key", validatecommand=validate_numeric).grid(row=pr+3, column=1, sticky="ew", padx=2, pady=0)

        # Output directory
        ctk.CTkLabel(form_card, text="Output directory", anchor="w").grid(row=pr+4, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkEntry(form_card, textvariable=self.output_directory_display, state="readonly", fg_color="#3a3f44").grid(row=pr+4, column=1, sticky="ew", padx=2, pady=0)
        ctk.CTkButton(form_card, text="Browse", width=80, fg_color="#00A678", hover=True, command=self.choose_output).grid(row=pr+4, column=2, padx=2, pady=0)

        # Quarter + Year
        ctk.CTkLabel(form_card, text="Select Quarter", anchor="w").grid(row=pr+5, column=0, sticky="w", padx=2, pady=0)
        ctk.CTkOptionMenu(form_card, variable=self.selected_quarter, values=["Q1","Q2","Q3","Q4"],
                           command=lambda v: self.update_files_from_quarter_year()).grid(row=pr+5, column=1, sticky="w", padx=2, pady=0)

        ctk.CTkLabel(form_card, text="Select Year", anchor="w").grid(row=pr+6, column=0, sticky="w", padx=2, pady=0)
        years_list = [str(y) for y in range(datetime.date.today().year-5, datetime.date.today().year+1)]
        ctk.CTkOptionMenu(form_card, variable=self.selected_year, values=years_list,
                           command=lambda v: self.update_files_from_quarter_year()).grid(row=pr+6, column=1, sticky="w", padx=2, pady=0)

        # Run + Reset + Log
        run_frame = ctk.CTkFrame(self.container, fg_color="transparent")
        run_frame.pack(fill="x", padx=5, pady=(2,5))

        btn_frame = ctk.CTkFrame(run_frame, fg_color="transparent")
        btn_frame.pack(pady=2)
        self.run_btn = ctk.CTkButton(btn_frame, text="Run Script", fg_color="#00A678", hover=True, width=150, command=self.run_script_thread)
        self.run_btn.pack(side="left", padx=5)
        self.reset_btn = ctk.CTkButton(btn_frame, text="Reset Defaults", fg_color="#FF6B6B", hover=True, width=150, command=self.reset_defaults)
        self.reset_btn.pack(side="left", padx=5)

        self.log_label = ctk.CTkLabel(run_frame, text="", anchor="nw")
        self.log_label.pack(fill="x", pady=(2,2), padx=2)

    # ------------------------
    # Helpers
    # ------------------------
    def update_files_from_quarter_year(self):
        q = int(self.selected_quarter.get()[1])
        y = int(self.selected_year.get())
        files = get_prev_quarter_files(q, y)
        self.assets_dataset_path.set(files["assets_dataset"])
        self.assets_dataset_path_display.set(shorten_path(files["assets_dataset"]))
        self.spot_curve_path.set(files["spot_curve"])
        self.spot_curve_path_display.set(shorten_path(files["spot_curve"]))
        self.spread_input_path.set(files["spread_input"])
        self.spread_input_path_display.set(shorten_path(files["spread_input"]))
        self.inflation_index_path.set(files["inflation_index"])
        self.inflation_index_path_display.set(shorten_path(files["inflation_index"]))

    def autofill_inputs(self):
        self.update_files_from_quarter_year()

    def browse_file(self, var, display_var):
        p = filedialog.askopenfilename(initialdir=INPUTS_DIR, filetypes=[("Excel files", "*.xlsx;*.xls")])
        if p:
            var.set(p)
            display_var.set(shorten_path(p))

    def choose_output(self):
        p = filedialog.askdirectory(initialdir=RESULTS_DIR)
        if p:
            self.output_directory.set(p)
            self.output_directory_display.set(shorten_path(p))

    def reset_defaults(self):
        self.valuation_date.set(valuation_date_default())
        self.spread_up.set("0.5")
        self.spread_down.set("0.5")
        self.ufr.set("3.3")

    def validate_inputs(self):
        try:
            datetime.datetime.strptime(self.valuation_date.get(), "%Y-%m-%d")
            float(self.spread_up.get())
            float(self.spread_down.get())
            float(self.ufr.get())
        except:
            messagebox.showerror("Error", "Check date and numeric fields")
            return False
        if not self.assets_dataset_path.get() or not self.spot_curve_path.get():
            messagebox.showerror("Error", "Required files missing")
            return False
        return True

    def run_script_thread(self):
        if not self.validate_inputs():
            return
        self.run_btn.configure(state="disabled")
        self.log_label.configure(text="Running… ⏳")

        def target():
            try:
                self.run_script()
                self.log_label.configure(text="Script eseguito ✅")
            except Exception as e:
                self.log_label.configure(text="Script FAILED ❌")
                tb = traceback.format_exc()
                messagebox.showerror("Errore Script", f"{str(e)}\n\nDettagli:\n{tb}")
            finally:
                self.run_btn.configure(state="normal")

        t = threading.Thread(target=target, daemon=True)
        t.start()

    def run_script(self):
        os.chdir(PROJECT_ROOT)
        from AssetPricingSource.Options import Options
        from AssetPricingSource.Executor import Executor
        from AssetPricingSource.Initializer import Initializer
        from AssetPricingSource.Reader import Reader
        from AssetPricingSource.PostProcessing import PostProcessing
        from AssetPricingSource.Writer import Writer
        from AssetPricingSource.SmithWilsonModel import SmithWilsonModel

        options = Options(
            assets_dataset_path=self.assets_dataset_path.get(),
            yearly_spot_rates_curve_path=self.spot_curve_path.get(),
            spread_input_path=self.spread_input_path.get(),
            inflation_index_path=self.inflation_index_path.get(),
            yearly_shocked_spot_rates_curve_path="",
            valuation_date=self.valuation_date.get(),
            curves_by_rating="",
            sensitivity_risk="Interest",
            spread_up=float(self.spread_up.get()),
            spread_down=float(self.spread_down.get()),
            UFR=float(self.ufr.get())/100,
            output_directory=self.output_directory.get()
        )

        initializer = Initializer(options)
        smith_wilson_model = SmithWilsonModel(options)
        reader = Reader(options, smith_wilson_model)
        post_processing = PostProcessing(options)
        writer = Writer(options)

        Executor(options, initializer, reader, post_processing, writer).run()

    def gui_exception_handler(self, exc, val, tb):
        tb_str = ''.join(traceback.format_exception(exc, val, tb))
        messagebox.showerror("Errore GUI", f"{val}\n\nDettagli:\n{tb_str}")

if __name__ == "__main__":
    app = App()
    app.mainloop()