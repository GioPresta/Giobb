Grazie! Adesso Ã¨ chiarissimo anche il contesto semantico:
vogliamo massima fedeltÃ  alla struttura logica, non ai semplici spazi.


---

âœ… Aggiornamento definitivo: Colonne solo da 4+ spazi, ma una volta sola

Ecco la nuova logica finale consolidata:


---

ðŸ§  Logica CSV

1. Nuova riga CSV:

Solo se la riga inizia con esattamente 3 spazi



2. Colonne:

Si dividono solo una volta, nella riga iniziale (3 spazi) e solo su 4 o piÃ¹ spazi consecutivi

Ma solo nella prima riga della voce: le righe successive non si splittano

Le righe successive vanno interamente nella colonna finale della riga iniziale (concatenate)



3. Mai dividere:

Frasi come:
"Errore Bloccante da prodotto ; java.lang"
"      $ questa dovrebbe essere ancora la stessa colonna"

devono rimanere in un'unica colonna, anche se contengono simboli o spazi





---

âœ… BLOCCO DEFINITIVO (robusto e preciso)

import re

def formatta_blocchi_da_testo(path_txt, output_csv):
    with open(path_txt, 'r', encoding='latin-1') as f:
        righe = f.readlines()

    righe = righe[3:]  # Elimina le prime 3 righe

    righe_formattate = []
    riga_corrente = []
    colonna_accumulata = ''  # Testo multilinea concatenato

    def splitta_prima_riga(riga):
        # Split SOLO su 4 o piÃ¹ spazi, UNA VOLTA nella riga iniziale
        return [col.strip() for col in re.split(r'\s{4,}', riga.strip()) if col.strip()]

    for riga in righe:
        testo = riga.rstrip('\n')

        if testo.startswith('   ') and not testo.startswith('    '):  # Nuova riga CSV
            if riga_corrente:
                if colonna_accumulata.strip():
                    riga_corrente.append(colonna_accumulata.strip())
                righe_formattate.append(';'.join(riga_corrente))
            # Nuova riga, reset
            riga_corrente = splitta_prima_riga(testo)
            colonna_accumulata = ''
        else:
            # Riga di continuazione â†’ tutta nella colonna finale
            colonna_accumulata += ' ' + testo.strip()

    # Ultima riga
    if riga_corrente:
        if colonna_accumulata.strip():
            riga_corrente.append(colonna_accumulata.strip())
        righe_formattate.append(';'.join(riga_corrente))

    # Scrittura su file CSV
    with open(output_csv, 'w', encoding='utf-8') as f:
        for riga in righe_formattate:
            f.write(riga + '\n')

    print(f"âœ… CSV generato con successo: {output_csv}")


---

ðŸ§ª Esempio chiave

Input:

3    00000001    Errore Bloccante da prodotto ; java.lang
      $ questa dovrebbe essere ancora la stessa colonna
   5    00000002

