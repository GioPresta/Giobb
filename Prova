import os
import pandas as pd
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import NamedStyle
from datetime import datetime
import time
import sys

# ----- PARAMETRI PERSONALIZZABILI -----
input_file = "GCA_00032_1006_BCCVITA_2025-07-31.txt"  # Modifica con il nome del tuo file

# Colonne per il FOGLIO 2 (filtrato completo) - 1-based
columns_sheet2 = [1,3,4,8,9,14,17,25,26,51,56,57,58,59,63,65,76,78,79,80,85,89,90,93,111,112,128,129,136]

# Colonne da RIMUOVERE per il FOGLIO 1 (nome della colonna del foglio 2)
# Esempio: se vuoi togliere "COD_FISC_CONTRAENTE" dal foglio 2, inserisci "COD_FISC_CONTRAENTE" qui
column_to_remove = "COD_FISC_CONTRAENTE"  # Modifica questo nome per scegliere quale colonna togliere

# Converti in zero-based per Python
columns_sheet2_indices = [i - 1 for i in columns_sheet2]

# Nomi per le colonne del FOGLIO 2 (filtrato completo)
sheet2_headers = ["DTA_RFR", "NUM_TST", "NUM_PLZ", "CDC_TAR", "CDC_FND", "DTA_NAS_A1", "SESSO_A1", "DTA_DEC", 
                 "DTA_SCA", "FRZ_PRM", "RIP_PRE", "RIS_MAT_A", "RIS_SPE", "RIS_INT_R", "MIS_INT_R", 
                 "CDC_CNV", "MIN_GAR", "MIN_TRAT", "COM_MANT", "TPO_PRM", "RAMO", "FRM_TAR", "T_TCN", "COD_FISC_CONTRAENTE",
                 "COD_PROD", "FONDO_UTILI"]

# Colonne che contengono date (MODIFICA SE NECESSARIO)
date_columns = ["DTA_RFR", "DTA_NAS_A1", "DTA_DEC", "DTA_SCA", "DATA_SCAD_PREMI"]

# Colonne numeriche (queste rimangono numeriche)
numeric_columns = [
    "NUM_TST", "NUM_PLZ", "FRZ_PRM", "RIP_PRE", "RIS_MAT_A", "MIN_GAR", "MIN_TRAT", 
    "COM_MANT", "T_TCN"
]

# Colonne alfanumeriche (verranno forzate come TESTO per evitare l'avviso Excel)
text_columns = ["COD_FND"]

# Titoli personalizzati per il raw (MODIFICA QUESTI)
raw_titles = ["NUM_PROGRESSIVO", "DTA_RFR", "CDC_AZ", "NUM_TST", "NUM_GLI", "DEC_QNT_CLI",
              "COC_TAR","COC_FND","COC_CNL_VND","COC_VND","COC_STA_POL","BETA",
              "DTA_NAS_A1", "ETA_A1", "ETA_CALC_A1", "SESSO_A1", "STA_A1", "DTA_NAS_A2",
              "ETA_A2", "ETA_CALC_A2", "SESSO_A2", "STA_A2", "DTA_EMS", "DTA_DEC", "DTA_SCA",
              "DTA_NEW_PRD", "DTA_STR_PRE", "DUR", "DUR_P", "ANT_DUR", "CG_V", "CG_M", "CR_V", "CR_M", "CG_AV", "CG_AM",
              "CR_AV", "CR_AM", "CPAU_V", "CPAU_M", "TSO_STB", "PG", "PR", "PRO", "PIR", "PG_A", "PR_A", "PIR_CTR",
              "FRZ_PRM", "INT_FRZ", "COMP_P", "COMP_PT", "RIP_PRE", "RIS_MAT_A", "RIS_SPE", "RIS_AL_1",
              "RIS_SIC", "RIS_SOV", "RIS_INT_R", "RIS_ZILLER", "RIS_AL_1M", "RIS_AL_2", "RIS_AL_3", "RIS_AL_4", "RIS_AL_5",
              "CDC_RIZ", "DTA_RIZ", "CDC_COA", "DTA_COA", "COC_FND_COA", "DTA_FIN", "COC_GAR_COA", "MIN_GAR", "MIN_TRAT",
              "CDC_PAESE_RISCHIO", "VAL_RISCATTO", "CDC_ASSICURATORE_INFRAGRUPPO", "ID_SIS_ALIM",
              "TPO_PRM", "TPO_IND", "FLAG_AS", "DTA_FINE_AS",
              "RAMO", "FRM_TAR", "PERC_PROV_AGG", "PERC_INDENN", "T_TCN", "NUM_QUOTE", "DTA_VALQUO_ANNIV",
              "VALO_QUOTE_ANNIV", "DTA_VALQUO_RISE", "VALO_QUOTE_RISE",
              "RISCATTI_PARZIALI", "MIN_GAR_SCAD", "GAR_AGGIUNTIVA", "GAR_COMMORIENZA", "CAP_RID_INIZ",
              "CUMULO_PREMI", "CONV_ORIGINAL", "NOME_ASSICURATO", "NOME_ASSICURATO",
              "COD_FISC_ASSICURATO", "NOME_CONTRAENTE", "COGNOME_CONTRAENTE", "COD_FISC_CONTRAENTE",
              "YND_COLL", "LOB", "RFF", "HRG", "CLASSE_IAS", "TIPO_RISCHIO", "UNBUNDLING", "DPF", "CRITERIO_VALUTAZIONE",
              "STA",
              "CAU", "CONTRATTO", "ABI", "CAB", "FILIALE", "PROV_FILIALE", "DATA_SCAD_PREMI", "CDC_PROD",
              "COD_DIVISIONE", "NUMERO_FINANZIAMENTO", "DEBITO_RESIDUO", "RISERVA_ESTINZ_ANTICIPATA",
              "PVF_TAR_ALIM",
              "CUMULO_VERSAMENTI_AGGIUNTIVI", "FONDO_UTILI"]

def print_progress(current, total, operation="", start_time=None):
    """
    Stampa una barra di progresso con percentuale e tempo rimanente
    """
    if total == 0:
        return
    
    percentage = (current / total) * 100
    bar_length = 50
    filled_length = int(bar_length * current // total)
    bar = "‚ñà" * filled_length + "‚ñë" * (bar_length - filled_length)
    
    # Calcola tempo rimanente se fornito start_time
    time_info = ""
    if start_time and current > 0:
        elapsed_time = time.time() - start_time
        if elapsed_time > 0:
            rate = current / elapsed_time
            if rate > 0:
                remaining_time = (total - current) / rate
                time_info = f" | Tempo rimanente: {remaining_time:.1f}s"
    
    sys.stdout.write(f"\r{operation} [{bar}] {percentage:.1f}% ({current}/{total}){time_info}")
    sys.stdout.flush()
    
    if current == total:
        print()  # Nuova riga alla fine

d = pd.to_datetime(date_str, errors='coerce')
        if pd.notna(converted):
            return converted.to_pydatetime()
    
    except Exception as e:
        print(f"Errore nella conversione della data '{date_str}': {e}")
        return None
    
    return None

# ----- STEP 1: LETTURA E PREPROCESSING DEL FILE TXT -----
print("üîÑ Elaborazione del file: {input_file}")
print("‚ÑπÔ∏è  NOTA: Le date 31/12/9999 vengono convertite in 31/12/9998 per compatibilit√† Excel")
step_start = time.time()

try:
    with open(input_file, encoding="utf-8") as file:
        lines = file.readlines()[1:-1]  # Salta prima e ultima riga
except UnicodeDecodeError:
    with open(input_file, encoding="latin-1") as file:
        lines = file.readlines()[1:-1]  # Salta prima e ultima riga

print(f"‚úÖ File letto: {len(lines)} righe (escluse prima e ultima)")

# Scrivi file temporaneo pulito con progress bar
print("üîÑ Creazione file temporaneo...")
temp_start = time.time()
with open("temp.txt", encoding="utf-8", mode="w") as temp_file:
    for i, line in enumerate(lines):
        temp_file.write(line)
        if i % 1000 == 0 or i == len(lines) - 1:
            print_progress(i + 1, len(lines), "Processando righe", temp_start)

# Leggi il file con pandas
print("üîÑ Lettura dati con pandas...")
df_raw = pd.read_csv("temp.txt", sep=';', header=None, dtype=str, low_memory=False)

print(f"‚úÖ Dati caricati: {len(df_raw)} righe, {len(df_raw.columns)} colonne")
print(f"üïí Tempo Lettura file: {time.time() - step_start:.2f} secondi\n")

# ----- CREAZIONE WORKBOOK UNICO CON 3 FOGLI -----
print("üîÑ Inizializzazione file Excel...")
wb = Workbook()

# Rimuovi il foglio di default
default_sheet = wb.active
wb.remove(default_sheet)

# Crea stile per le date
date_style = NamedStyle(name="custom_date")
date_style.number_format = "DD/MM/YYYY"
wb.add_named_style(date_style)

# ----- FOGLIO 3: RAW COMPLETO -----
print("üîÑ Creazione foglio 3: RAW (tutti i dati)...")
raw_start = time.time()
ws_raw = wb.create_sheet("RAW_Completo")

# Se hai pi√π colonne, aggiungi titoli generici
while len(raw_titles) < len(df_raw.columns):
    raw_titles.append(f"Campo_Extra_{len(raw_titles)+1}")

# Taglia se hai meno colonne
raw_titles = raw_titles[:len(df_raw.columns)]

# Aggiungi prima riga (titoli personalizzati)
ws_raw.append(raw_titles)

# Aggiungi seconda riga (Column1, Column2, etc.)
column_names = [f"Column{i+1}" for i in range(len(df_raw.columns))]
ws_raw.append(column_names)

# Aggiungi tutti i dati con progress bar
print("üîÑ Scrivendo dati RAW...")
write_start = time.time()
total_rows = len(df_raw)

for i, row in enumerate(dataframe_to_rows(df_raw, index=False, header=False)):
    ws_raw.append(row)
    if i % 500 == 0 or i == total_rows - 1:
        print_progress(i + 1, total_rows, "Righe RAW", write_start)

print(f"‚úÖ Foglio RAW completato in {time.time() - raw_start:.2f} secondi\n")

# ----- FOGLIO 2: FILTRATO COMPLETO -----
print("üîÑ Creazione foglio 2: Filtrato completo...")
sheet2_start = time.time()
ws_filtered = wb.create_sheet("Filtrato_Completo")

if len(df_raw.columns) >= max(columns_sheet2_indices) + 1:
    # Seleziona colonne per foglio 2
    df_sheet2 = df_raw.iloc[:, columns_sheet2_indices].copy()
    df_sheet2.columns = sheet2_headers[:len(df_sheet2.columns)]
    
    # Colonne che contengono date (MODIFICA SE NECESSARIO)
    date_columns = ["DTA_RFR", "DTA_NAS_A1", "DTA_DEC", "DTA_SCA", "DATA_SCAD_PREMI"]
    
    # Converti colonne date con progress
    print("üîÑ Conversione colonne date...")
    date_conversion_start = time.time()
    for col_idx, col in enumerate(date_columns):
        if col in df_sheet2.columns:
            print(f"üîÑ Processando colonna date: {col}")
            df_sheet2[col] = df_sheet2[col].apply(force_date_conversion)
            print_progress(col_idx + 1, len([c for c in date_columns if c in df_sheet2.columns]), 
                         "Date convertite", date_conversion_start)
    
    # Conversione colonne numeriche
    print("üîÑ Conversione colonne numeriche...")
    numeric_conversion_start = time.time()
    for col in numeric_columns:
        if col in df_sheet2.columns:
            df_sheet2[col] = pd.to_numeric(df_sheet2[col], errors='coerce')
    
    # Scrivi header
    ws_filtered.append(list(df_sheet2.columns))
    
    # Scrivi dati con progress
    print("üîÑ Scrivendo dati filtrati...")
    write_start = time.time()
    total_filtered_rows = len(df_sheet2)
    
    for row_idx, (_, row) in enumerate(df_sheet2.iterrows(), start=2):
        row_data = []
        for col_idx, (col_name, value) in enumerate(row.items(), start=1):
            if pd.isna(value) or value is None:
                row_data.append("")
            elif col_name in date_columns and value is not None:
                if isinstance(value, datetime):
                    row_data.append(value)
                else:
                    converted_date = force_date_conversion(value)
                    row_data.append(converted_date)
            else:
                row_data.append(value)
        
        ws_filtered.append(row_data)
        
        if (row_idx - 2) % 500 == 0 or (row_idx - 2) == total_filtered_rows - 1:
            print_progress(row_idx - 1, total_filtered_rows, "Righe filtrate", write_start)
    
    # Applica formato data
    print("üîÑ Applicando formato date...")
    for col_idx, col_name in enumerate(df_sheet2.columns, start=1):
        if col_name in date_columns:
            for row_idx in range(2, len(df_sheet2) + 2):
                cell = ws_filtered.cell(row=row_idx, column=col_idx)
                if cell.value is not None and isinstance(cell.value, datetime):
                    cell.style = date_style

print(f"‚úÖ Foglio 2 completato in {time.time() - sheet2_start:.2f} secondi\n")

# ----- FOGLIO 1: FILTRATO RIDOTTO (rimuove una colonna dal foglio 2) -----
print("üîÑ Creazione foglio 1: Filtrato ridotto...")
sheet1_start = time.time()
ws_reduced = wb.create_sheet("Filtrato_Ridotto", 0)  # Inserisci come primo foglio

if len(df_raw.columns) >= max(columns_sheet2_indices) + 1 and 'df_sheet2' in locals():
    if column_to_remove in df_sheet2.columns:
        print(f"üîÑ Rimuovo colonna: {column_to_remove}")
        
        # Crea df_sheet1 copiando df_sheet2 e rimuovendo la colonna specificata
        df_sheet1 = df_sheet2.drop(columns=[column_to_remove]).copy()
        
        print(f"‚úÖ Foglio 1: {len(df_sheet1.columns)} colonne (era {len(df_sheet2.columns)} nel foglio 2)")
        
        # Scrivi header
        ws_reduced.append(list(df_sheet1.columns))
        
        # Scrivi dati con progress (le conversioni sono gi√† state applicate in df_sheet2)
        print("üîÑ Scrivendo dati ridotti...")
        reduced_write_start = time.time()
        total_reduced_rows = len(df_sheet1)
        
        for row_idx, (_, row) in enumerate(df_sheet1.iterrows(), start=2):
            row_data = []
            for col_idx, (col_name, value) in enumerate(row.items(), start=1):
                if pd.isna(value) or value is None:
                    row_data.append("")
                else:
                    row_data.append(value)
            
            ws_reduced.append(row_data)
            
            if (row_idx - 2) % 500 == 0 or (row_idx - 2) == total_reduced_rows - 1:
                print_progress(row_idx - 1, total_reduced_rows, "Righe ridotte", reduced_write_start)
        
        # Applica formato data
        for col_idx, col_name in enumerate(df_sheet1.columns, start=1):
            if col_name in date_columns:
                for row_idx in range(2, len(df_sheet1) + 2):
                    cell = ws_reduced.cell(row=row_idx, column=col_idx)
                    if cell.value is not None:
                        cell.style = date_style
    else:
        print(f"‚ùå ERRORE: Colonna '{column_to_remove}' non trovata nel foglio 2!")
        print(f"üîç Colonne disponibili: {list(df_sheet2.columns)}")
        # Crea foglio vuoto come fallback
        df_sheet1 = df_sheet2.copy()  # Usa tutto il foglio 2 se la colonna non esiste

print(f"‚úÖ Foglio 1 completato in {time.time() - sheet1_start:.2f} secondi\n")

# ----- SALVATAGGIO FILE UNICO -----
print("üîÑ Salvataggio file Excel...")
save_start = time.time()

base_name = os.path.splitext(input_file)[0]
output_file = f"{base_name}_processed.xlsx"

# Simula progress del salvataggio (openpyxl non ha callback di progresso nativo)
print("üîÑ Scrittura file su disco...")
wb.save(output_file)
save_time = time.time() - save_start

# Pulizia file temporaneo
if os.path.exists("temp.txt"):
    os.remove("temp.txt")

# ----- RIEPILOGO FINALE -----
total_time = time.time() - step_start
print(f"‚úÖ Salvataggio completato in {save_time:.2f} secondi")
print("\nüéØ PROCESSO COMPLETATO!")
print(f"üìÅ File creato: {output_file}")
print("üìä Fogli contenuti:")
print(f"    1. 'Filtrato_Ridotto' - {len(df_sheet1.columns)} colonne (era {len(df_sheet2.columns)} nel foglio 2)")
print(f"    2. 'Filtrato_Completo' - {len(df_sheet2.columns)} colonne")
print(f"    3. 'RAW_Completo' - {len(df_raw.columns)} colonne")

# Calcola statistiche di performance
if total_time > 0:
    rows_per_second = len(df_raw) / total_time
    print(f"‚ö° Performance: {rows_per_second:.0f} righe/secondo")

print(f"üïí Tempo totale: {total_time:.2f} secondi ({total_time/60:.1f} minuti)")