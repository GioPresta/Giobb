Perfetto, adesso è chiarissimo:
Vuoi che lo script principale legga automaticamente i file sia in UTF-8 che Latin-1, nel caso in cui uno dei due fallisca — senza messaggi diagnostici extra.


---

✅ Soluzione: apertura con fallback utf-8 → latin1

Ti allego qui lo script completo e definitivo, aggiornato così:

Legge i file prima in utf-8

Se fallisce, li riapre in latin1

Gestisce:

6 righe di intestazione

4 righe di trattini

1+ righe di dati (contratti)

chiusura con *****


Genera riepilogo.txt e riepilogo.csv corretti



---

🧾 Codice completo con doppia codifica

import os
import re
import csv

# Cartella contenente i file .txt
cartella_input = r'C:/ReportBatch'  # <--- Cambia qui

# Pattern riconoscimento struttura
inizio_intestazione = re.compile(r'\bLIVELLO\b', re.IGNORECASE)
riga_asterischi = re.compile(r'^\*{5,}$')
riga_decorativa = re.compile(r'^[-\s]{10,}$')

header_lines = []
righe_dati = []
intestazione_salvata = False

# Funzione per leggere un file in utf-8 o latin1
def apri_file(path):
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.readlines()
    except UnicodeDecodeError:
        with open(path, 'r', encoding='latin1') as f:
            return f.readlines()

# Legge tutti i file .txt
file_txt = [f for f in os.listdir(cartella_input) if f.endswith('.txt') and not f.startswith('riepilogo')]

if not file_txt:
    print("❌ Nessun file .txt trovato in:", cartella_input)
    exit()

for nome_file in file_txt:
    percorso_file = os.path.join(cartella_input, nome_file)
    lines = apri_file(percorso_file)

    # Cerca riga con LIVELLO
    start_index = None
    for i, line in enumerate(lines):
        if inizio_intestazione.search(line.strip()):
            start_index = i
            break
    else:
        continue  # se non trova LIVELLO, salta il file

    # Salva le 6 righe di intestazione (una volta sola)
    if not intestazione_salvata:
        header_lines = [lines[start_index + j].rstrip('\n') for j in range(6)]
        intestazione_salvata = True

    # Salta le 4 righe di trattini
    index = start_index + 10

    # Legge le righe dati fino agli asterischi
    for line in lines[index:]:
        riga = line.strip()
        if riga_asterischi.match(riga):
            break
        if riga:
            righe_dati.append(riga)

# Costruisce intestazioni verticali da 6 righe
def crea_colonne_da_header(righe):
    split = [re.split(r'\s{2,}', r.strip()) for r in righe]
    max_col = max(len(r) for r in split)
    for r in split:
        while len(r) < max_col:
            r.append('')
    return [' '.join(col).strip() for col in zip(*split)]

final_headers = crea_colonne_da_header(header_lines)

# Scrittura riepilogo.txt
with open('riepilogo.txt', 'w', encoding='utf-8') as f:
    for r in header_lines:
        f.write(r + '\n')
    for r in righe_dati:
        f.write(r + '\n')

# Scrittura riepilogo.csv
with open('riepilogo.csv', 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(final_headers)
    for r in righe_dati:
        valori = re.split(r'\s{2,}', r.strip())
        writer.writerow(valori)

print(f"\n✅ Completato. File letti: {len(file_txt)}")
print(f"📄 Contratti estratti: {len(righe_dati)}")
print("📁 Output: riepilogo.txt + riepilogo.csv")


---

✅ Pronto all’uso

1. Cambia la cartella nella riga:



cartella_input = r'C:/ReportBatch'

2. Salva, esegui lo script e ricevi:

riepilogo.txt con intestazione unica e tutte le righe polizza

riepilogo.csv pronto per Excel





---

Se vuoi:

aggiungere colonna con nome file di provenienza

esportare anche in .xlsx


...dimmi pure!

